<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document Access Requests Admin</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        /* --- Custom Properties for Theme --- */
        :root {
            --primary-green: #047857; /* Tailwind emerald-700 */
            --light-green: #d1fae5; /* Tailwind emerald-100 */
            --lighter-green: #ecfdf5; /* Tailwind emerald-50 */
            --dark-green: #064e3b; /* Tailwind emerald-900 */
            --gold-accent: #d97706; /* Tailwind amber-600 */
            --light-gold: #fef3c7; /* Tailwind amber-100 */
            --dark-gold: #92400e; /* Tailwind amber-800 */
            --text-primary: #1f2937; /* Tailwind gray-800 */
            --text-secondary: #4b5563; /* Tailwind gray-600 */
            --border-color: #e5e7eb; /* Tailwind gray-200 */
            --background-light: #f9fafb; /* Tailwind gray-50 */
            --background-page: #f3f4f6; /* Tailwind gray-100 */
            --danger-red: #dc2626; /* Tailwind red-600 */
            --danger-red-dark: #b91c1c; /* Tailwind red-800 */
            --danger-red-light: #fee2e2; /* Tailwind red-100 */
             --sky-blue-light: #e0f2fe; /* sky-100 */
             --sky-blue-dark: #0369a1; /* sky-700 */
             --sky-blue-border: #bae6fd; /* sky-200 */
        }

        /* --- Base Styles --- */
        body {
            font-family: "Inter", sans-serif;
            background-color: var(--background-page);
            color: var(--text-primary);
            line-height: 1.6;
            
            
        }
        /* Main Page Title */
        .page-title {
            color: var(--dark-green);
            border-bottom: 2px solid var(--light-green);
            padding-bottom: 0.5rem;
        }
        /* Main Container */
        .main-container {
            width: 1200px;
             background-color: #fff;
             border-radius: 0.75rem; /* Slightly more rounded */
             box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        /* --- Filter Controls --- */
        .filter-controls {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            gap: 1rem; /* Space between filter groups */
            align-items: center; /* Align items vertically */
        }
        .filter-group {
            display: flex;
            align-items: center;
            gap: 0.5rem; /* Space within a group */
        }
        .filter-group label {
             font-size: 0.875rem; /* Slightly smaller label */
             font-weight: 500; /* Medium weight */
             color: var(--text-secondary);
             flex-shrink: 0;
        }
        /* Adjust date input width */
        .form-date {
            max-width: 150px; /* Limit width of date inputs */
        }
         /* Column Visibility Toggle & Date Range Button */
        .column-toggle-button, .date-range-button { /* Added date-range-button */
            background-color: #fff;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            display: inline-flex; /* Ensure icon and text align */
            align-items: center;
        }
        .column-toggle-button:hover, .date-range-button:hover {
             background-color: var(--background-light);
             border-color: var(--primary-green);
             color: var(--text-primary);
        }
        .column-toggle-button i, .date-range-button i { margin-right: 0.3rem; }

        .column-checklist {
            display: none; /* Hidden by default */
            position: absolute;
            background-color: white;
            border: 1px solid var(--border-color);
            border-radius: 0.375rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 0.5rem 0; /* Adjust padding */
            z-index: 50; /* Ensure it's above table */
            max-height: 250px; /* Limit height */
            overflow-y: auto;
            margin-top: 0.25rem; /* Space below button */
            list-style: none; /* Remove default list styles */
            right: 0; /* Align to the right of the button group */
        }
        .column-checklist li {
            padding: 0;
            margin: 0;
        }
        .column-checklist.visible { display: block; }
        .column-checklist label {
            display: flex;
            align-items: center;
            padding: 0.4rem 0.8rem;
            font-size: 0.9rem;
            cursor: pointer;
            white-space: nowrap;
        }
         .column-checklist label:hover { background-color: var(--lighter-green); }
        .column-checklist input[type="checkbox"] { margin-right: 0.5rem; }


        /* --- View/Layout Controls Container --- */
        .view-layout-controls {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping */
            align-items: center;
            gap: 0.75rem; /* Space between control groups */
            background-color: var(--background-light); /* Subtle background */
            padding: 0.5rem 0.75rem; /* Padding around the controls */
            border-radius: 0.5rem; /* Rounded corners */
        }
        .view-layout-controls .filter-group {
             margin-bottom: 0; /* Remove bottom margin if any */
        }


        /* --- View Switcher --- */
        .view-switcher button {
            padding: 0.5rem 1rem; border: 1px solid var(--border-color); background-color: #fff;
            color: var(--text-secondary); transition: all 0.2s ease;
        }
        .view-switcher button:first-child { border-radius: 0.375rem 0 0 0.375rem; }
        .view-switcher button:last-child { border-radius: 0 0.375rem 0.375rem 0; border-left-width: 0; }
        .view-switcher button.active {
            background-color: var(--primary-green); color: #fff; border-color: var(--primary-green); z-index: 10;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
        }
        .view-switcher button:hover:not(.active) { background-color: var(--background-light); }
        .view-switcher button i { margin-right: 0.3rem; }

        /* --- Table Styling (Detailed View) --- */
        .table-container {
            overflow-x: auto;
            width: 100%;
            border-radius: 0.5rem;
             -webkit-overflow-scrolling: touch;
        }
        .table-view {
             min-width: 950px; /* Adjusted min-width for new column */
             width: 100%;
             border-collapse: collapse;
        }
        .table-view th, .table-view td { padding: 0.85rem 1rem; text-align: left; border-bottom: 1px solid var(--border-color); vertical-align: middle; font-size: 0.9rem; }
        .table-view th {
            background-color: var(--primary-green);
            color: white;
            font-weight: 600;
            white-space: nowrap;
            position: sticky; top: 0; /* Keep header sticky */
            z-index: 1;
            border-left: 1px solid var(--dark-green);
            border-right: 1px solid var(--dark-green);
        }
         .table-view th:first-child { border-left: none; }
         .table-view th:last-child { border-right: none; }
        .table-view th.sortable { cursor: pointer; position: relative; padding-right: 1.5rem; }
        .table-view th.sortable .sort-icon { position: absolute; right: 0.5rem; top: 50%; transform: translateY(-50%); font-size: 0.8em; color: var(--light-green); opacity: 0.7; transition: opacity 0.2s ease; }
        .table-view th.sortable:hover .sort-icon { opacity: 1; }
        .table-view th.sorted-asc .sort-icon, .table-view th.sorted-desc .sort-icon { opacity: 1; color: white; }
        .table-view tbody tr { transition: background-color 0.2s ease-in-out; }
        .table-view tbody tr:hover td { background-color: var(--lighter-green); cursor: pointer; }
        .table-view tbody tr:hover:has(a.view-doc-button:hover) td,
        .table-view tbody tr:hover:has(select:hover) td { background-color: transparent; cursor: default; }

        .table-view td { white-space: nowrap; color: var(--text-secondary); }
        .table-view td:first-child { font-weight: 500; color: var(--text-primary); } /* First cell styling */
        .table-view td.wrap-text { white-space: normal; }
        .table-view td.actions-cell { white-space: nowrap; }
        /* Add truncation style for specific table cells if needed */
         .table-view td.truncate-cell {
             max-width: 200px; /* Adjust max width as needed */
             overflow: hidden;
             text-overflow: ellipsis;
             white-space: nowrap;
         }


        /* --- Pagination Controls --- */
        .pagination-controls {
            display: flex;
            justify-content: center; /* Center items */
            align-items: center;
            padding: 1rem 0.5rem; /* Add some padding */
            margin-top: 0.5rem; /* Space above controls */
            border-top: 1px solid var(--border-color);
            font-size: 0.9rem;
            color: var(--text-secondary);
            flex-wrap: wrap; /* Allow wrapping on small screens */
            gap: 0.5rem; /* Add gap between elements */
        }
        .pagination-controls button, .pagination-controls .page-number, .pagination-controls .ellipsis {
            background-color: #fff;
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.4rem 0.8rem;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease;
            font-weight: 500;
            min-width: 36px; /* Ensure buttons have minimum width */
            text-align: center;
        }
        .pagination-controls .ellipsis {
            border: none;
            background: none;
            cursor: default;
            padding: 0.4rem 0.2rem; /* Reduce padding for ellipsis */
        }
        .pagination-controls button:hover:not(:disabled), .pagination-controls .page-number:hover:not(.active) {
            background-color: var(--lighter-green);
            border-color: var(--primary-green);
            color: var(--dark-green);
        }
        .pagination-controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: var(--background-light);
        }
        .pagination-controls .page-number.active {
            background-color: var(--primary-green);
            border-color: var(--primary-green);
            color: #fff;
            font-weight: 600;
            cursor: default;
        }
        .pagination-info { display: none; }


        /* --- Tile View Styling --- */
        .tile-view-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 1.25rem; }
        .tile-item { background-color: #fff; border: 1px solid var(--border-color); border-radius: 0.5rem; box-shadow: 0 1px 3px rgba(0,0,0,0.05); transition: transform 0.2s ease, box-shadow 0.2s ease; display: flex; flex-direction: column; justify-content: space-between; overflow: hidden; /* Prevent content spill */ }
        .tile-item:hover:not(:has(select:hover)) { transform: translateY(-3px); box-shadow: 0 5px 15px rgba(0,0,0,0.08); cursor: pointer; }
        .tile-header {
            background-color: var(--primary-green);
            color: white;
            padding: 0.75rem 1.25rem; /* Adjust padding */
        }
        .tile-header .tile-request-id { font-size: 0.75rem; color: var(--light-green); /* Lighter color on green */ margin-bottom: 0.25rem; display: block; font-weight: 500; }
        .tile-header .tile-title {
            font-size: 1.1rem; font-weight: 600; color: white; margin-bottom: 0.25rem;
            overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
         }
        .tile-header .tile-author { font-size: 0.9rem; color: var(--light-green); /* Lighter color on green */ margin-bottom: 0; }
        .tile-body { padding: 1rem 1.25rem; flex-grow: 1; } /* Padding for body content */
        .tile-body p { margin-bottom: 0.3rem; font-size: 0.9rem; color: var(--text-secondary); }
        .tile-body strong { color: var(--text-primary); }
        .tile-body .tile-requester { font-size: 0.9rem; color: var(--text-primary); margin-bottom: 0.75rem; }
        .tile-actions { margin-top: auto; /* Push actions to bottom */ padding: 0.75rem 1.25rem; border-top: 1px solid var(--border-color); display: flex; justify-content: flex-start; /* Align action to the left */ align-items: center; gap: 0.5rem; background-color: var(--background-light); /* Light background for footer */ }

        /* --- List View Styling --- */
        .list-view-container ul { list-style: none; padding: 0; margin: 0; }
        .list-item {
            background-color: #fff;
            border: 1px solid var(--border-color);
            border-left: 4px solid var(--light-green); /* Default light green left border */
            border-radius: 0.375rem;
            margin-bottom: 0.5rem;
            overflow: hidden;
            transition: border-left-color 0.2s ease; /* Smooth transition for border color */
        }
         .list-item:hover {
             border-left-color: var(--primary-green); /* Darker green border on hover */
         }
         .list-item:hover .list-item-summary {
             background-color: var(--lighter-green); /* Keep subtle background on summary hover */
         }
        .list-item-summary {
            padding: 0.85rem 1rem; display: flex; justify-content: space-between; align-items: center;
            cursor: pointer; transition: background-color 0.2s ease;
            background-color: transparent; /* Make summary background transparent */
            color: var(--text-primary);
             border-bottom: 1px solid var(--border-color); /* Add border like table rows */
        }
        .list-item-summary .list-info { display: flex; flex-direction: column; flex-grow: 1; margin-right: 1rem; gap: 0.1rem; min-width: 0; /* Allow info section to shrink */ }
        .list-item-summary .list-info span { display: block; }
        .list-item-summary .list-info .list-request-id { font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 0.25rem; font-weight: 500; }
        .list-item-summary .list-info .list-requester-name { font-weight: 600; color: var(--dark-green); font-size: 1rem; }
        .list-item-summary .list-info .list-book-title {
             font-weight: 500; color: var(--text-primary); margin-top: 0.25rem;
             overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
        }
        .list-item-summary .list-info .list-author { font-size: 0.85rem; color: var(--text-secondary);}
        .list-item-summary .list-info .list-volume { font-size: 0.8rem; color: var(--text-secondary); font-style: italic;}
        .list-item-summary .list-info .list-email, .list-item-summary .list-info .list-affiliation { font-size: 0.85rem; color: var(--text-secondary); display: none; }
        .list-item-summary .list-actions { display: flex; align-items: center; gap: 0.75rem; flex-shrink: 0; }
        .list-item-summary .expand-icon { margin-left: 0.5rem; color: var(--text-secondary); transition: transform 0.3s ease; } /* Default icon color */
        .list-item.expanded { border-left-color: var(--primary-green); }
        .list-item.expanded .list-item-summary { background-color: var(--lighter-green); } /* Light green when expanded */
        .list-item.expanded .list-item-summary .expand-icon { transform: rotate(180deg); }
        .list-item-details { max-height: 0; overflow: hidden; transition: max-height 0.4s ease-out, padding 0.4s ease-out, border-top-color 0.4s ease-out; padding: 0 1rem; background-color: var(--background-light); border-top: 1px solid transparent; }
        .list-item.expanded .list-item-details { max-height: 500px; padding: 1rem 1rem; border-top: 1px solid var(--border-color); } /* Use standard border color */
        .list-item-details p { margin-bottom: 0.4rem; font-size: 0.9rem; color: var(--text-secondary); }
        .list-item-details strong { color: var(--text-primary); min-width: 100px; display: inline-block; }
        .list-item-details .reason-tags-display .reason-tag-display { display: inline-block; background-color: #e0f2fe; color: #0369a1; padding: 0.1rem 0.5rem; margin: 0.1rem; border-radius: 9999px; font-size: 0.7rem; font-weight: 600; }
        .list-item-details .reason-details-text { background-color: #e5e7eb; padding: 0.5rem; border-radius: 0.25rem; margin-top: 0.25rem; font-size: 0.85rem; display: block; white-space: pre-wrap; }
         /* Display rejection reason */
         .rejection-reason-display {
             background-color: var(--danger-red-light);
             border: 1px solid var(--danger-red);
             border-radius: 0.375rem;
             padding: 0.5rem 0.75rem;
             margin-top: 0.5rem;
             font-size: 0.85rem;
             color: var(--danger-red-dark);
         }
         .rejection-reason-display strong { color: var(--danger-red-dark); }


         /* Style for the action dropdown (used in List and Tile views) */
        .list-action-dropdown, .tile-action-dropdown {
            padding: 0.4rem 2.2rem 0.4rem 0.8rem;
            font-size: 0.9rem;
            font-weight: 500;
            border: 1px solid var(--border-color);
            border-radius: 0.375rem;
            appearance: none;
            cursor: pointer;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23b45309' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.7rem center;
            background-repeat: no-repeat;
            background-size: 1em 1em;
            min-width: 120px;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            text-align: center; /* Center the selected option text */
        }
        /* Apply pending colors specifically */
        .list-action-dropdown.status-pending, .tile-action-dropdown.status-pending {
            background-color: var(--light-gold);
            color: var(--dark-gold);
            border-color: var(--gold-accent);
        }
         /* Style options within the dropdown */
        .list-action-dropdown option, .tile-action-dropdown option {
            background-color: white;
            color: var(--text-primary);
            text-align: left; /* Keep option text left-aligned */
        }
         /* Attempt hover style (browser support varies) */
         .list-action-dropdown option:hover, .tile-action-dropdown option:hover {
             background-color: var(--light-gold) !important; /* Use !important cautiously */
             color: var(--dark-gold) !important;
         }

        .list-action-dropdown.status-pending:focus, .tile-action-dropdown.status-pending:focus {
            outline: 2px solid transparent; outline-offset: 2px; border-color: var(--gold-accent);
            box-shadow: 0 0 0 2px rgba(217, 119, 6, 0.2); /* Amber focus ring */
        }


        /* --- Common Styles --- */
        /* Style for the "View Document" button (used on <a> tag) */
        .view-doc-button {
            display: inline-block;
            padding: 0.3rem 0.8rem;
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--dark-gold);
            background-color: var(--light-gold);
            border: 1px solid var(--gold-accent);
            border-radius: 0.375rem;
            text-decoration: none;
            transition: all 0.2s ease;
            cursor: pointer;
            text-align: center;
        }
        .view-doc-button:hover {
            background-color: var(--gold-accent);
            color: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .view-doc-button i { margin-right: 0.25rem; }

        /* MODIFIED: Status label styles to match dropdown */
        .status-label {
            font-weight: 500; /* Match dropdown weight */
            font-size: 0.9rem; /* Match dropdown font size */
            padding: 0.4rem 0.8rem; /* Match dropdown padding (adjust as needed) */
            border-radius: 0.375rem; /* Match dropdown radius */
            display: inline-block;
            border: 1px solid transparent;
            text-align: center; /* Center text */
            min-width: 120px; /* Match dropdown width */
            white-space: nowrap; /* Prevent wrapping */
        }
        .status-pending { background-color: #fef3c7; color: #b45309; border-color: #fde68a; } /* Amber */
        .status-approved { background-color: #dcfce7; color: #166534; border-color: #bbf7d0; } /* Green */
        .status-rejected { background-color: #fee2e2; color: #991b1b; border-color: #fecaca; } /* Red */

        .form-select, .form-input, .form-date { /* Added .form-date */
            border: 1px solid var(--border-color); border-radius: 0.375rem; padding: 0.5rem 0.75rem;
            font-size: 0.9rem; transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            color: var(--text-secondary); /* Default text color for date placeholder */
        }
        .form-select:focus, .form-input:focus, .form-date:focus {
            outline: 2px solid transparent; outline-offset: 2px; border-color: var(--primary-green);
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.2); /* Emerald focus ring */
        }
         /* Style date input when a value is selected */
        .form-date:valid {
            color: var(--text-primary); /* Darker text color when date is chosen */
        }
        .form-select { appearance: none; background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e"); background-position: right 0.5rem center; background-repeat: no-repeat; background-size: 1.25em 1.25em; padding-right: 2.5rem; }

        /* --- Modal Styles --- */
        .reason-tags-display .reason-tag-display { display: inline-block; background-color: var(--sky-blue-light); color: var(--sky-blue-dark); padding: 0.1rem 0.5rem; margin: 0.1rem; border-radius: 9999px; font-size: 0.7rem; font-weight: 600; } /* Sky blue */
        textarea[readonly] { background-color: var(--background-light); cursor: default; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.65); display: flex; justify-content: center; align-items: center; z-index: 1000; visibility: hidden; opacity: 0; transition: opacity 0.3s ease, visibility 0s linear 0.3s; overflow-y: auto; padding: 20px 0; }
        .modal-overlay.visible { visibility: visible; opacity: 1; transition: opacity 0.3s ease; }
        .modal-content { background-color: #fff; padding: 2rem; border-radius: 0.75rem; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15); max-width: 90%; width: 600px; position: relative; margin: auto; text-align: left; border-top: 4px solid var(--primary-green); } /* Green top border */
        .modal-content h2 { color: var(--dark-green); }
        .close-button { position: absolute; top: 1rem; right: 1rem; font-size: 1.5rem; cursor: pointer; color: #9ca3af; transition: color 0.3s ease; }
        .close-button:hover { color: var(--text-primary); }
        #modalDetailsContent p strong { color: var(--dark-green); font-weight: 600; } /* Bolder labels */
        #modalDetailsContent hr { border-color: var(--light-green); }
        /* Modal Buttons */
        .modal-button {
            font-weight: 600; 
            padding: 0.6rem 1.25rem; 
            border-radius: 0.375rem;
            transition: all 0.2s ease;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .modal-button:focus {
            outline: none;
            ring: 2px;
            ring-offset: 2px;
        }
        .approve-button { background-color: var(--primary-green); color: white; border: 1px solid var(--primary-green); }
        .approve-button:hover { background-color: var(--dark-green); border-color: var(--dark-green); }
        .approve-button:focus { ring-color: var(--primary-green); }
        .reject-button { background-color: var(--danger-red); color: white; border: 1px solid var(--danger-red); } /* Red-600 */
        .reject-button:hover { background-color: var(--danger-red-dark); border-color: var(--danger-red-dark); } /* Red-800 */
        .reject-button:focus { ring-color: var(--danger-red); }
        /* Secondary button style (for Cancel) */
        .secondary-button {
            background-color: #fff; color: var(--text-secondary); border: 1px solid var(--border-color);
        }
         .secondary-button:hover { background-color: var(--background-light); }
         .secondary-button:focus { ring-color: var(--primary-green); }

         /* Rejection Reason Modal Specific Styles */
         #reasonTagsContainer {
             display: flex;
             flex-wrap: wrap;
             gap: 0.5rem;
             margin-bottom: 1rem;
         }
         .reason-tag {
             display: inline-block;
             padding: 0.3rem 0.75rem;
             border: 1px solid var(--border-color);
             border-radius: 9999px; /* Pill shape */
             font-size: 0.85rem;
             cursor: pointer;
             transition: all 0.2s ease;
             background-color: #fff;
             color: var(--text-secondary);
         }
         .reason-tag:hover {
             background-color: var(--lighter-green);
             border-color: var(--primary-green);
         }
         .reason-tag.active {
             background-color: var(--sky-blue-light);
             color: var(--sky-blue-dark);
             border-color: var(--sky-blue-border);
             font-weight: 500;
         }
         #rejectionOtherReasonContainer {
             margin-top: 0.75rem;
         }


        /* --- Confirmation Message Styling --- */
        .confirmation-message {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: white; padding: 0.8rem 1.5rem; border-radius: 0.5rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15); z-index: 1001;
            opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0s linear 0.3s;
            font-size: 0.9rem; font-weight: 500;
        }
        /* MODIFIED: Added background colors for confirmation types */
        .confirmation-message.success { background-color: var(--dark-green); }
        .confirmation-message.error { background-color: var(--danger-red-dark); }
        .confirmation-message.visible { opacity: 1; visibility: visible; transition: opacity 0.3s ease; }

        /* Confirmation message */
        #confirmationMessage {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border-radius: 4px;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 1000;
            font-weight: 500;
            max-width: 90%;
            text-align: center;
        }
        
        #confirmationMessage.visible {
            opacity: 1;
        }
        
        #confirmationMessage.success {
            background-color: #059669;
            color: white;
        }
        
        #confirmationMessage.error {
            background-color: #DC2626;
            color: white;
        }
        
        #confirmationMessage.warning {
            background-color: #F59E0B;
            color: white;
        }

        /* Detailed confirmation popup */
        #detailedConfirmation {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.25);
            padding: 1.5rem;
            max-width: 90%;
            width: 450px;
            z-index: 3000; /* Higher z-index to ensure it appears above ALL other elements */
            display: none;
            animation: fadeIn 0.3s ease-out;
            /* Add additional visibility properties */
            opacity: 1;
            visibility: visible;
            transition: opacity 0.3s, visibility 0.3s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -48%); }
            to { opacity: 1; transform: translate(-50%, -50%); }
        }
        
        #detailedConfirmation .file-status-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }
        
        #detailedConfirmation .message-title {
            font-weight: 600;
            font-size: 1.1rem;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }
        
        #detailedConfirmation .message-details {
            color: var(--text-secondary);
            margin-bottom: 1rem;
            line-height: 1.5;
        }
        
        #detailedConfirmation .buttons-container {
            display: flex;
            justify-content: flex-end;
        }
        
        #detailedConfirmation button.close-button {
            color: var(--text-secondary);
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0.2rem;
            position: absolute;
            top: 1rem;
            right: 1rem;
            transition: color 0.2s ease;
        }
        
        #detailedConfirmation button.close-button:hover {
            color: var(--text-primary);
        }
        
        #detailedConfirmation button.ok-button {
            background-color: var(--background-light);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            font-weight: 500;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        #detailedConfirmation button.ok-button:hover {
            background-color: var(--border-color);
        }
        
        #detailedConfirmation.success .header-icon {
            color: var(--primary-green);
        }
        
        #detailedConfirmation.warning .header-icon {
            color: var(--gold-accent);
        }
        
        #detailedConfirmation.error .header-icon {            
            color: var(--danger-red);        
        }                
        
        /* Add styles for content container */        
        #detailedConfirmation .content-container {            
            position: relative;            
            padding: 0.5rem 1rem 1rem 1rem;        
        }                
        
        #detailedConfirmation.success .content-container {            
            border-left: 4px solid var(--primary-green);        
        }                
        
        #detailedConfirmation.warning .content-container {            
            border-left: 4px solid var(--gold-accent);        
        }                
        
        #detailedConfirmation.error .content-container {            
            border-left: 4px solid var(--danger-red);        
        }                
        
        #detailedConfirmation .flex {            
            display: flex;        
        }                
        
        #detailedConfirmation .items-center {            
            align-items: center;        
        }                
        
        #detailedConfirmation .mb-4 {            
            margin-bottom: 1rem;        
        }                
        
        #detailedConfirmation .mr-3 {            
            margin-right: 0.75rem;        
        }

        /* Added CSS for detailed confirmation */
        #detailedConfirmation .header-icon {
            font-size: 1.5rem;
        }
        
        #detailedConfirmation .file-status-icon {
            display: inline-block;
            margin-right: 0.5rem;
        }

        #detailedConfirmation .file-status-badge {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            border-radius: 0.375rem;
            font-weight: 500;
            text-align: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        #detailedConfirmation .file-status-badge::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.4) 50%, rgba(255,255,255,0) 100%);
            animation: shine 2s infinite;
            pointer-events: none;
        }
        
        @keyframes shine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        /* Existing header-icon and file-status-icon styles */
        #detailedConfirmation .header-icon {
            font-size: 1.5rem;
        }
        
        #detailedConfirmation .file-status-icon {
            display: inline-block;
            margin-right: 0.5rem;
            font-size: 1.25rem; /* Larger icon size */
        }
    </style>
</head>
<body class="p-0">
    <!-- Navbar container -->
  <div id="navbar-header"></div>
    <div id="sidebar-container"></div>
  
    <div class="main-container max-w-7xl mx-auto p-6 md:p-8">
        <h1 class="page-title text-2xl md:text-3xl font-bold mb-6 text-center">Document Access Requests</h1>

        <div class="flex flex-col lg:flex-row justify-between items-center mb-6 gap-4 lg:gap-6">
            <div class="filter-controls w-full lg:w-auto flex-grow lg:flex-grow-0">
                <div class="filter-group">
                    <label for="statusFilter">Status:</label>
                    <select id="statusFilter" class="form-select">
                        <option value="all">All Status</option>
                        <option value="pending">Pending</option>
                        <option value="approved">Approved</option>
                        <option value="rejected">Rejected</option>
                    </select>
                </div>
                 <div class="filter-group">
                    <button id="dateRangeButton" class="date-range-button" type="button">
                        <i class="fas fa-calendar-alt"></i>
                        <span id="dateRangeButtonText">Date Range</span>
                    </button>
                 </div>
                <div class="filter-group flex-grow sm:flex-grow-0">
                    <label for="searchInput" class="sr-only">Search:</label> <input type="text" id="searchInput" class="form-input w-full sm:w-48" placeholder="Search...">
                </div>
            </div>

            <div class="view-layout-controls flex-shrink-0">
                 <div class="filter-group" id="layoutControlGroup"> <label for="columnOrderSelect">Layout:</label>
                    <select id="columnOrderSelect" class="form-select">
                        <option value="default">Default</option>
                        <option value="requesterFirst">Requester First</option>
                        <option value="bookFirst">Book First</option>
                    </select>
                </div>
                 <div class="filter-group relative" id="columnToggleGroup"> <button id="columnToggleButton" class="column-toggle-button" type="button" style="display: none;"> <i class="fas fa-columns"></i> Columns
                    </button>
                    <ul id="columnChecklist" class="column-checklist">
                        </ul>
                </div>
                <div class="view-switcher flex flex-shrink-0" role="group">
                    <button type="button" data-view="list" title="List View">
                        <i class="fas fa-list fa-fw"></i> <span class="hidden sm:inline">List</span>
                    </button>
                    <button type="button" data-view="detailed" title="Detailed Table View" class="active">
                        <i class="fas fa-table fa-fw"></i> <span class="hidden sm:inline">Detailed</span>
                    </button>
                    <button type="button" data-view="tile" title="Tile View">
                        <i class="fas fa-th-large fa-fw"></i> <span class="hidden sm:inline">Tile</span>
                    </button>
                </div>
            </div>
        </div>

        <div id="requestsContentContainer">
            <p class="text-center text-gray-600" id="loadingMessage">Loading requests...</p>
        </div>
    </div>

    <div id="requestDetailsModal" class="modal-overlay">
       <div class="modal-content">
            <span class="close-button" id="closeDetailsModalButton">&times;</span>
            <h2 class="text-xl font-semibold mb-6 text-center">Request Details</h2>
            <div id="modalDetailsContent">
                <p><strong>Request ID:</strong> <span id="detailRequestId"></span></p>
                <hr class="my-3">
                <p><strong>Requester Name:</strong> <span id="detailFullName"></span></p>
                <p><strong>Email:</strong> <span id="detailEmail"></span></p>
                <p><strong>Affiliation:</strong> <span id="detailAffiliation"></span></p>
                <p><strong>Date Requested:</strong> <span id="detailRequestedAt"></span></p>
                <hr class="my-3">
                <p><strong>Book Title:</strong> <span id="detailBookTitle"></span></p>
                <p><strong>Author:</strong> <span id="detailAuthorName"></span></p>
                <p><strong>Volume:</strong> <span id="detailVolume"></span></p>
                <div class="mt-2"> <a id="detailDocumentLink" href="#" target="_blank" class="view-doc-button">View Document</a>
                </div>
                <hr class="my-3">
                <div class="mt-4">
                    <p class="text-sm font-bold mb-1">Reason(s) for Access:</p>
                    <div id="detailReasons" class="reason-tags-display"></div>
                </div>
                <div id="detailReasonDetailsSection" class="mt-4 hidden">
                    <label class="block text-sm font-bold mb-2">Reason Details:</label>
                    <textarea id="detailReasonDetails" class="shadow-sm appearance-none border rounded-md w-full py-2 px-3 text-gray-700 leading-tight bg-gray-50" rows="4" readonly></textarea>
                </div>
                 <div id="detailRejectionReasonSection" class="mt-4 hidden">
                     <p class="rejection-reason-display"><strong>Rejection Reason:</strong><br><span id="detailRejectionReason"></span></p>
                 </div>
                <hr class="my-3">
                <p class="mt-4"><strong>Status:</strong> <span id="detailStatus" class="status-label"></span></p>
                <p id="detailProcessedAt" class="mt-2 text-sm text-gray-500 hidden"><strong>Processed At:</strong> <span></span></p>
            </div>
            <div id="modalActions" class="flex justify-center gap-4 mt-6">
                </div>
        </div>
    </div>

     <div id="rejectionReasonModal" class="modal-overlay">
         <div class="modal-content" style="border-top-color: var(--danger-red);">
             <span class="close-button" id="closeRejectionModalButton">&times;</span>
             <h2 class="text-xl font-semibold mb-4 text-center text-red-700">Provide Rejection Reason</h2>
             <p class="text-sm text-gray-600 mb-4">Select reason(s) for rejecting request <strong id="rejectModalRequestId"></strong>.</p>
             <form id="rejectionForm">
                 <input type="hidden" id="rejectionRequestId">
                 <div class="mb-4">
                     <label class="block text-sm font-medium text-gray-700 mb-2">Select Reason(s):</label>
                     <div id="reasonTagsContainer">
                        <span class="reason-tag" data-reason="Insufficient Information">Insufficient Information</span>
                        <span class="reason-tag" data-reason="Duplicate Request">Duplicate Request</span>
                        <span class="reason-tag" data-reason="Policy Violation">Policy Violation</span>
                        <span class="reason-tag" data-reason="Document Unavailable">Document Unavailable</span>
                        <span class="reason-tag" data-reason="Invalid Justification">Invalid Justification</span>
                        <span class="reason-tag" data-reason="Other">Other (Specify Below)</span>
                     </div>
                 </div>
                 <div id="rejectionOtherReasonContainer" class="mb-4 hidden">
                     <label for="rejectionOtherReasonText" class="block text-sm font-medium text-gray-700 mb-1">Specify Other Reason:</label>
                     <textarea id="rejectionOtherReasonText" name="rejectionOtherReason" rows="3" class="form-input w-full" placeholder="Please provide details..."></textarea>
                 </div>
                 <div class="flex justify-end gap-3 mt-6">
                     <button type="button" id="cancelRejectionButton" class="modal-button secondary-button">Cancel</button>
                     <button type="submit" class="modal-button reject-button">Submit Rejection</button>
                 </div>
             </form>
         </div>
     </div>

     <div id="dateRangeModal" class="modal-overlay">
        <div class="modal-content">
            <span class="close-button" id="closeDateRangeModalButton">&times;</span>
            <h2 class="text-xl font-semibold mb-6 text-center">Select Date Range</h2>
            <form id="dateRangeForm">
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6">
                    <div>
                        <label for="modalStartDate" class="block text-sm font-medium text-gray-700 mb-1">Start Date:</label>
                        <input type="date" id="modalStartDate" name="startDate" class="form-date w-full">
                    </div>
                    <div>
                        <label for="modalEndDate" class="block text-sm font-medium text-gray-700 mb-1">End Date:</label>
                        <input type="date" id="modalEndDate" name="endDate" class="form-date w-full">
                    </div>
                </div>
                <div class="flex justify-end gap-3 mt-6">
                    <button type="button" id="cancelDateRangeButton" class="modal-button secondary-button">Cancel</button>
                    <button type="submit" class="modal-button approve-button">Apply</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Rejection Confirmation Modal -->
    <div id="rejectionConfirmationModal" class="modal-overlay">
        <div class="modal-content" style="border-top-color: var(--danger-red);">
            <span class="close-button" id="closeRejectionConfirmationModalButton">&times;</span>
            <h2 class="text-xl font-semibold mb-4 text-center text-red-700">Request Rejected</h2>
            
            <div class="text-center mb-6">
                <div class="inline-block bg-red-100 rounded-full p-3 mb-4">
                    <i class="fas fa-times-circle text-3xl text-red-600"></i>
                </div>
                <p class="text-lg font-medium text-gray-800 mb-2">The request has been rejected successfully</p>
                <p class="text-sm text-gray-600" id="rejectionConfirmationDetails">The requester will be notified by email.</p>
            </div>
            
            <div class="bg-red-50 border-l-4 border-red-500 p-4 mb-6">
                <div class="flex items-start">
                    <div class="flex-shrink-0">
                        <i class="fas fa-info-circle text-red-600"></i>
                    </div>
                    <div class="ml-3">
                        <p class="text-sm text-red-800" id="rejectionReasonDisplay">
                            Rejection reason will appear here
                        </p>
                    </div>
                </div>
            </div>
            
            <div id="rejectionEmailStatus" class="bg-yellow-50 border-l-4 border-yellow-500 p-4 mb-6 hidden">
                <div class="flex items-start">
                    <div class="flex-shrink-0">
                        <i class="fas fa-exclamation-triangle text-yellow-600"></i>
                    </div>
                    <div class="ml-3">
                        <p class="text-sm text-yellow-800" id="rejectionEmailMessage">
                            Email notification status will appear here
                        </p>
                    </div>
                </div>
            </div>
            
            <div class="flex justify-center gap-3 mt-6">
                <button id="rejectionConfirmationCloseButton" class="modal-button secondary-button">Close</button>
            </div>
        </div>
    </div>


    <div id="confirmationMessage" class="confirmation-message"> Action successful! </div>

    <div id="detailedConfirmation" class="success">
        <!-- This will be populated dynamically -->
    </div>

    <script>
        // --- Mock Data ---
        let requests = [];
        let filteredAndSortedRequests = []; // Holds all filtered/sorted items

        // --- State Variables ---
        let currentSort = { column: 'requestedAt', direction: 'desc' };
        let currentFilter = 'all';
        let currentSearchTerm = '';
        let startDateFilter = '';
        let endDateFilter = '';
        let currentView = 'detailed';
        let currentPage = 1;
        const itemsPerPage = 10;
        let currentColumnOrder = 'default'; // Default layout
        let visibleColumns = new Set(); // Holds keys of visible columns

        // --- DOM Element References ---
        const requestsContentContainer = document.getElementById('requestsContentContainer');
        const loadingMessage = document.getElementById('loadingMessage');
        const statusFilterSelect = document.getElementById('statusFilter');
        const dateRangeButton = document.getElementById('dateRangeButton'); // Added
        const dateRangeButtonText = document.getElementById('dateRangeButtonText'); // Added
        // const startDateInput = document.getElementById('startDateFilter'); // Removed
        // const endDateInput = document.getElementById('endDateFilter');   // Removed
        const searchInput = document.getElementById('searchInput');
        const viewSwitcher = document.querySelector('.view-switcher');
        const columnOrderSelect = document.getElementById('columnOrderSelect');
        const columnToggleButton = document.getElementById('columnToggleButton');
        const columnChecklist = document.getElementById('columnChecklist');
        const layoutControlGroup = document.getElementById('layoutControlGroup');
        const columnToggleGroup = document.getElementById('columnToggleGroup');
        const requestDetailsModal = document.getElementById('requestDetailsModal');
        const closeDetailsModalButton = document.getElementById('closeDetailsModalButton');
        const modalDetailsContent = document.getElementById('modalDetailsContent');
        const modalActions = document.getElementById('modalActions');
        const confirmationMessage = document.getElementById('confirmationMessage');
        // Rejection Modal Elements
        const rejectionReasonModal = document.getElementById('rejectionReasonModal');
        const closeRejectionModalButton = document.getElementById('closeRejectionModalButton');
        const cancelRejectionButton = document.getElementById('cancelRejectionButton');
        const rejectionForm = document.getElementById('rejectionForm');
        const rejectionRequestIdInput = document.getElementById('rejectionRequestId');
        const reasonTagsContainer = document.getElementById('reasonTagsContainer');
        const rejectionOtherReasonContainer = document.getElementById('rejectionOtherReasonContainer');
        const rejectionOtherReasonText = document.getElementById('rejectionOtherReasonText');
        const rejectModalRequestIdSpan = document.getElementById('rejectModalRequestId');
         // Date Range Modal Elements
        const dateRangeModal = document.getElementById('dateRangeModal');
        const closeDateRangeModalButton = document.getElementById('closeDateRangeModalButton');
        const cancelDateRangeButton = document.getElementById('cancelDateRangeButton');
        const dateRangeForm = document.getElementById('dateRangeForm');
        const modalStartDateInput = document.getElementById('modalStartDate');
        const modalEndDateInput = document.getElementById('modalEndDate');


        // Modal detail elements
        const detailRequestId = document.getElementById('detailRequestId');
        const detailBookTitle = document.getElementById('detailBookTitle');
        const detailAuthorName = document.getElementById('detailAuthorName');
        const detailVolume = document.getElementById('detailVolume');
        // const detailDocumentId = document.getElementById('detailDocumentId'); // Removed reference to static element
        const detailFullName = document.getElementById('detailFullName');
        const detailEmail = document.getElementById('detailEmail');
        const detailAffiliation = document.getElementById('detailAffiliation');
        const detailRequestedAt = document.getElementById('detailRequestedAt');
        const detailDocumentLink = document.getElementById('detailDocumentLink');
        const detailReasons = document.getElementById('detailReasons');
        const detailReasonDetailsSection = document.getElementById('detailReasonDetailsSection');
        const detailReasonDetails = document.getElementById('detailReasonDetails');
        const detailRejectionReasonSection = document.getElementById('detailRejectionReasonSection'); // Added
        const detailRejectionReason = document.getElementById('detailRejectionReason'); // Added
        const detailStatus = document.getElementById('detailStatus');
        const detailProcessedAt = document.getElementById('detailProcessedAt');

        // --- Local Storage Keys ---
        const STORAGE_KEY = 'documentAccessRequests';
        const COLUMN_ORDER_KEY = 'documentAccessColumnOrder';
        const VISIBLE_COLUMNS_KEY = 'documentAccessVisibleColumns'; // Added

        // --- Column Definitions ---
        // Define columns with their key, header text, and whether they are sortable/toggleable
        const columnDefinitions = {
            id: { header: 'Request ID', sortable: true, toggleable: true },
            document_id: { header: 'Document ID', sortable: true, toggleable: true }, // Database field name
            full_name: { header: 'Requester Name', sortable: true, toggleable: true }, // Database field name
            email: { header: 'Email', sortable: false, toggleable: true },
            affiliation: { header: 'Affiliation', sortable: false, toggleable: true },
            book_title: { header: 'Book Title', sortable: true, toggleable: true }, // May come from document table
            author_name: { header: 'Author', sortable: true, toggleable: true }, // May come from document table
            created_at: { header: 'Date Requested', sortable: true, format: formatDate, toggleable: true }, // Database field name
            status: { header: 'Status', sortable: true, format: (val, req) => formatStatus(val, req), toggleable: false }, // Status always visible
            reviewed_at: { header: 'Processed At', sortable: true, format: formatDateTime, toggleable: true }, // Database field name
            actions: { 
                header: 'Actions', 
                sortable: false, 
                format: (val, req) => {
                    const docUrl = req.document_url || req.documentUrl || '#';
                    return `<a href="${docUrl}" target="_blank" class="view-doc-button" data-action="view" data-needs-auth="true" title="View Document">View</a>`;
                }, 
                toggleable: false 
            } // Actions always visible
        };

        // Define different column order presets
        const columnOrders = {
            default: ['status', 'full_name', 'book_title'], // Only these 3 for default
            requesterFirst: ['id', 'document_id', 'full_name', 'email', 'affiliation', 'book_title', 'author_name', 'created_at', 'status', 'reviewed_at', 'actions'], // Database field names
            bookFirst: ['id', 'document_id', 'book_title', 'author_name', 'full_name', 'email', 'affiliation', 'created_at', 'status', 'reviewed_at', 'actions'] // Database field names
        };

        // --- Functions ---

        /** Helper to format status cell (label or dropdown) */
        function formatStatus(status, request) {
            if (status === 'pending') {
                 // Use list-action-dropdown styling for consistency, but apply to table cell context if needed
                return `
                    <select class="list-action-dropdown status-pending" data-action="process" data-request-id="${request.id}">
                        <option value="" disabled selected>Pending</option>
                        <option value="approved">Approve</option>
                        <option value="rejected">Reject</option>
                    </select>`;
            } else {
                const statusClass = `status-${status}`;
                const statusText = status.charAt(0).toUpperCase() + status.slice(1);
                return `<span class="status-label ${statusClass}">${statusText}</span>`;
            }
        }


        /** Loads requests, column order, and visible columns from localStorage or initializes defaults. */
        async function loadData() {
            try {
                // Get auth token using our helper function
                const token = getAuthToken();
                if (!token) {
                    // Try to refresh token before failing
                    const newToken = await refreshAuthToken();
                    if (!newToken) {
                    throw new Error('No authentication token found. Please log in again.');
                    }
                }

                // Get user info to check role
                const userInfo = JSON.parse(sessionStorage.getItem('userInfo') || '{}');
                if (!userInfo.role || userInfo.role.toLowerCase() !== 'admin') {
                    throw new Error('You do not have permission to access this page. Admin access required.');
                }

                // Fetch requests from API using current token (which might be refreshed)
                const currentToken = getAuthToken(); // Get token again in case it was refreshed
                
                console.log('Fetching document requests...');
                const response = await fetch('/api/document-requests', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${currentToken}`
                    },
                    credentials: 'include'
                });
                
                console.log('Response status:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Error response:', errorText);
                    throw new Error(`Failed to fetch requests: ${response.status} ${errorText}`);
                }
                
                const data = await response.json();
                console.log('Received data:', data);
                
                if (!Array.isArray(data)) {
                    console.error('Expected array but got:', typeof data);
                    throw new Error('Invalid response format');
                }
                
                requests = data;

            // Load column order preference (remains frontend logic)
            const storedOrder = localStorage.getItem(COLUMN_ORDER_KEY);
            if (storedOrder && columnOrders[storedOrder]) {
                currentColumnOrder = storedOrder;
            } else {
                currentColumnOrder = 'default'; // Default if nothing stored or invalid
            }
             columnOrderSelect.value = currentColumnOrder; // Update dropdown selection

             // Load visible columns preference (remains frontend logic)
            const storedVisible = localStorage.getItem(VISIBLE_COLUMNS_KEY);
            if (storedVisible) {
                try {
                    visibleColumns = new Set(JSON.parse(storedVisible));
                } catch (e) {
                    console.error("Error parsing visible columns:", e);
                    // Default to all toggleable columns if parsing fails
                    visibleColumns = new Set(Object.keys(columnDefinitions).filter(key => columnDefinitions[key].toggleable));
                }
            } else {
                 // Default to all toggleable columns
                visibleColumns = new Set(Object.keys(columnDefinitions).filter(key => columnDefinitions[key].toggleable));
            }

            renderColumnVisibilityControl(); // Populate checklist
            applyFiltersAndSort(); // Initial filter/sort and render
            } catch (error) {
                console.error('Error loading requests:', error);
                showConfirmationMessage('Error loading requests. Please try again.', 'error');
                // Show error in the UI with a login button
                requestsContentContainer.innerHTML = `
                    <div class="text-center text-red-600 py-4">
                        <p>Error loading requests: ${error.message}</p>
                        <p class="text-sm mt-2">Please check the console for more details.</p>
                        <button onclick="window.location.href='/log-in.html'" class="mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
                            Log in again
                        </button>
                    </div>`;
            }
         }

        /** Initializes mock data including requestedAt and documentId. */
        function initializeMockData() {
             // CJ/kuys: This function should be REMOVED when fetching real data.
             // This is just placeholder data for the frontend development.
             const now = new Date().toISOString(); const oneDayAgo = new Date(Date.now() - 86400000).toISOString(); const twoDaysAgo = new Date(Date.now() - 2 * 86400000).toISOString(); const threeDaysAgo = new Date(Date.now() - 3 * 86400000).toISOString(); const fourDaysAgo = new Date(Date.now() - 4 * 86400000).toISOString(); const fiveDaysAgo = new Date(Date.now() - 5 * 86400000).toISOString(); const sixDaysAgo = new Date(Date.now() - 6 * 86400000).toISOString(); const sevenDaysAgo = new Date(Date.now() - 7 * 86400000).toISOString();
             requests = [
                 { id: 'req-' + Date.now() + '-1', documentId: 'DOC101', requestedAt: threeDaysAgo, documentUrl: '#/view-doc/gatsby', bookTitle: 'The Great Gatsby', authorName: 'F. Scott Fitzgerald', volume: null, fullName: 'Alice Smith', email: 'alice.smith@example.com', affiliation: 'University of Example', reasons: ['Academic Research', 'Coursework/Study'], reasonDetails: '', status: 'pending', processedAt: null, rejectionReason: null },
                 { id: 'req-' + Date.now() + '-2', documentId: 'DOC102', requestedAt: fiveDaysAgo, documentUrl: '#/view-doc/mockingbird', bookTitle: 'To Kill a Mockingbird', authorName: 'Harper Lee', volume: null, fullName: 'Bob Johnson', email: 'bob.j@company.net', affiliation: 'Tech Solutions Inc.', reasons: ['Professional Development', 'Other'], reasonDetails: 'Need to review for compliance standards.', status: 'pending', processedAt: null, rejectionReason: null },
                 { id: 'req-' + Date.now() + '-3', documentId: 'DOC103', requestedAt: twoDaysAgo, documentUrl: '#/view-doc/1984', bookTitle: '1984', authorName: 'George Orwell', volume: null, fullName: 'Charlie Davis', email: 'charlie.d@web.org', affiliation: 'Independent Researcher', reasons: ['Personal Interest', 'Writing Project'], reasonDetails: 'Writing a book on digital archiving.', status: 'pending', processedAt: null, rejectionReason: null },
                 { id: 'req-' + Date.now() + '-4', documentId: 'DOC104', requestedAt: sevenDaysAgo, documentUrl: '#/view-doc/pride', bookTitle: 'Pride and Prejudice', authorName: 'Jane Austen', volume: null, fullName: 'Diana Prince', email: 'diana.p@justice.gov', affiliation: 'Government Archives', reasons: ['Institutional Requirement'], reasonDetails: '', status: 'approved', processedAt: oneDayAgo, rejectionReason: null },
                 { id: 'req-' + Date.now() + '-5', documentId: 'DOC105', requestedAt: sixDaysAgo, documentUrl: '#/view-doc/hitchhiker', bookTitle: 'The Hitchhiker\'s Guide to the Galaxy', authorName: 'Douglas Adams', volume: null, fullName: 'Clark Kent', email: 'clark.k@dailyplanet.com', affiliation: 'Daily Planet', reasons: ['Personal Interest'], reasonDetails: '', status: 'rejected', processedAt: twoDaysAgo, rejectionReason: 'Request outside of standard access policy.' },
                 { id: 'req-' + Date.now() + '-6', documentId: 'DOC106', requestedAt: fourDaysAgo, documentUrl: '#/view-doc/moby', bookTitle: 'Moby Dick', authorName: 'Herman Melville', volume: null, fullName: 'Eva Green', email: 'eva.g@sea.org', affiliation: 'Marine Biology Institute', reasons: ['Academic Research'], reasonDetails: '', status: 'approved', processedAt: now, rejectionReason: null },
                 { id: 'req-' + Date.now() + '-7', documentId: 'DOC107', requestedAt: sevenDaysAgo, documentUrl: '#/view-doc/war', bookTitle: 'War and Peace', authorName: 'Leo Tolstoy', volume: 'II', fullName: 'Frank Castle', email: 'frank.c@military.net', affiliation: 'Retired', reasons: ['Personal Interest'], reasonDetails: '', status: 'rejected', processedAt: oneDayAgo, rejectionReason: 'Duplicate request.' },
                 { id: 'req-' + Date.now() + '-8', documentId: 'DOC107', requestedAt: oneDayAgo, documentUrl: '#/view-doc/war', bookTitle: 'War and Peace', authorName: 'Leo Tolstoy', volume: 'I', fullName: 'Grace Hopper', email: 'grace.h@navy.mil', affiliation: 'US Navy (Retired)', reasons: ['Academic Research'], reasonDetails: '', status: 'pending', processedAt: null, rejectionReason: null },
                 { id: 'req-' + Date.now() + '-9', documentId: 'DOC108', requestedAt: now, documentUrl: '#/view-doc/sun', bookTitle: 'The Sun Also Rises', authorName: 'Ernest Hemingway', volume: null, fullName: 'Bruce Wayne', email: 'bruce@wayne.com', affiliation: 'Wayne Enterprises', reasons: ['Personal Interest'], reasonDetails: '', status: 'pending', processedAt: null, rejectionReason: null },
                 { id: 'req-' + Date.now() + '-10', documentId: 'DOC109', requestedAt: oneDayAgo, documentUrl: '#/view-doc/catcher', bookTitle: 'The Catcher in the Rye', authorName: 'J.D. Salinger', volume: null, fullName: 'Selina Kyle', email: 'selina@cats.com', affiliation: 'Self-employed', reasons: ['Personal Interest'], reasonDetails: '', status: 'pending', processedAt: null, rejectionReason: null },
                 { id: 'req-' + Date.now() + '-11', documentId: 'DOC110', requestedAt: twoDaysAgo, documentUrl: '#/view-doc/grapes', bookTitle: 'The Grapes of Wrath', authorName: 'John Steinbeck', volume: null, fullName: 'Peter Parker', email: 'peter.p@bugle.com', affiliation: 'Daily Bugle', reasons: ['Coursework/Study'], reasonDetails: '', status: 'approved', processedAt: now, rejectionReason: null },
                 { id: 'req-' + Date.now() + '-12', documentId: 'DOC111', requestedAt: threeDaysAgo, documentUrl: '#/view-doc/brave', bookTitle: 'Brave New World', authorName: 'Aldous Huxley', volume: null, fullName: 'Tony Stark', email: 'tony@stark.com', affiliation: 'Stark Industries', reasons: ['Professional Development'], reasonDetails: '', status: 'pending', processedAt: null, rejectionReason: null },
                 { id: 'req-' + Date.now() + '-13', documentId: 'DOC112', requestedAt: fourDaysAgo, documentUrl: '#/view-doc/amazon', bookTitle: 'A Comprehensive Analysis of the Long-Term Effects of Deforestation on Local Weather Patterns in the Amazon Basin.', authorName: 'Dr. Elena Vance', volume: null, fullName: 'Walter White', email: 'walter.w@science.edu', affiliation: 'Climate Research Center', reasons: ['Academic Research'], reasonDetails: '', status: 'approved', processedAt: oneDayAgo, rejectionReason: null }
             ];
             saveRequests(); // Save mock data if initializing
        }

        /** Saves the current `requests` array to localStorage. */
        function saveRequests() {
            // CJ/kuys: This function will likely be REMOVED or changed.
            // Saving is handled by backend calls in handleAction.
            // You might keep localStorage for *preferences* like column order, but not the main data.
             try { localStorage.setItem(STORAGE_KEY, JSON.stringify(requests)); } catch (e) { console.error("Error saving requests:", e); alert("Could not save changes."); }
        }
         /** Saves the selected column order to localStorage. */
        function saveColumnOrder() {
             try { localStorage.setItem(COLUMN_ORDER_KEY, currentColumnOrder); } catch (e) { console.error("Error saving column order:", e); }
        }
         /** Saves the set of visible columns to localStorage. */
        function saveVisibleColumns() {
             try { localStorage.setItem(VISIBLE_COLUMNS_KEY, JSON.stringify(Array.from(visibleColumns))); } catch (e) { console.error("Error saving visible columns:", e); }
        }


        /** Formats an ISO date string to locale date/time string. */
        function formatDateTime(isoString) { /* ... (same as before) ... */
             if (!isoString) return 'N/A'; try { const d=new Date(isoString); return isNaN(d.getTime())?'Invalid':d.toLocaleString(); } catch(e){ return 'Error'; }
        }
         /** Formats an ISO date string to locale date string (Date only). */
        function formatDate(isoString) { /* ... (same as before) ... */
            if (!isoString) return 'N/A'; try { const date = new Date(isoString); if (isNaN(date.getTime())) return 'Invalid Date'; return date.toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' }); } catch (e) { console.error("Error formatting date:", isoString, e); return 'Error'; }
        }


        /** MODIFIED: Applies filters (including date) and sorting, updates the full list, then calls the active view renderer. */
        function applyFiltersAndSort() {
            // CJ/kuys: This function needs significant changes for backend integration.
            // Instead of filtering/sorting the 'requests' array here,
            // you should trigger an API call to fetch data based on the
            // current filter values (currentFilter, startDateFilter, endDateFilter, currentSearchTerm)
            // and sorting parameters (currentSort.column, currentSort.direction).
            // Pagination (currentPage, itemsPerPage) should also be sent to the backend.

            // Example conceptual API call structure:
            /*
            const params = new URLSearchParams({
                status: currentFilter,
                startDate: startDateFilter,
                endDate: endDateFilter,
                search: currentSearchTerm,
                sortBy: currentSort.column,
                sortDir: currentSort.direction,
                page: currentPage,
                limit: itemsPerPage
            });
            fetch(`/api/requests?${params.toString()}`)
                .then(response => response.json())
                .then(data => {
                    // Assuming the API returns { requests: [...], totalItems: ... }
                    requests = data.requests; // Update the local copy if needed for other views? Or maybe not.
                    filteredAndSortedRequests = data.requests; // Use the data directly returned from API
                    // You might need to update totalPages based on data.totalItems
                    renderActiveView(); // Re-render with the fetched data
                })
                .catch(error => console.error('Error fetching filtered/sorted data:', error));
            */

            // --- Current Frontend Filtering/Sorting (To be replaced by backend logic) ---
             let tempRequests = requests;

             // Apply status filter
             if (currentFilter !== 'all') { tempRequests = tempRequests.filter(req => req.status === currentFilter); }

             // Apply date range filter
             const startDate = startDateFilter ? new Date(startDateFilter).setHours(0, 0, 0, 0) : null;
             const endDate = endDateFilter ? new Date(endDateFilter).setHours(23, 59, 59, 999) : null; // Include full end day

             if (startDate || endDate) {
                 tempRequests = tempRequests.filter(req => {
                     if (!req.requestedAt) return false; // Skip requests without a date
                     const requestedDate = new Date(req.requestedAt).getTime();
                     const afterStart = startDate ? requestedDate >= startDate : true;
                     const beforeEnd = endDate ? requestedDate <= endDate : true;
                     return afterStart && beforeEnd;
                 });
             }

             // Apply search term filter
             if (currentSearchTerm) { const lowerSearchTerm = currentSearchTerm.toLowerCase(); tempRequests = tempRequests.filter(req => Object.values(req).some(val => String(val).toLowerCase().includes(lowerSearchTerm))); }

             // Apply sort (using the current column order to access data)
             if (currentSort.column) {
                 tempRequests.sort((a, b) => {
                     let valA = a[currentSort.column];
                     let valB = b[currentSort.column];
                     if (valA == null) valA = '';
                     if (valB == null) valB = '';
                     if (currentSort.column === 'processedAt' || currentSort.column === 'requestedAt') {
                         valA = valA ? new Date(valA).getTime() : 0;
                         valB = valB ? new Date(valB).getTime() : 0;
                     } else if (typeof valA === 'string') {
                         valA = valA.toLowerCase();
                         valB = valB.toLowerCase();
                     }
                     let comp = (valA > valB) ? 1 : (valA < valB ? -1 : 0);
                     return currentSort.direction === 'desc' ? (comp * -1) : comp;
                 });
             }

             filteredAndSortedRequests = tempRequests; // Update the full list

             // Reset to page 1 whenever filters/sort change OR when switching views
             currentPage = 1;

             renderActiveView(); // Render the currently selected view
             // --- End of Frontend Filtering/Sorting ---
        }

        /** MODIFIED: Renders the view based on the `currentView` state and controls visibility. */
        function renderActiveView() {
            // Clear the main content container *before* rendering any view
            requestsContentContainer.innerHTML = '';
            if (filteredAndSortedRequests.length === 0) {
                requestsContentContainer.innerHTML = '<p class="text-center text-gray-600 py-4">No requests match the current filters.</p>';
                // Still need to manage control visibility even if no results
            }

             // Show/hide Layout and Columns controls based on view
            const showLayoutControls = currentView === 'detailed';
            layoutControlGroup.style.display = showLayoutControls ? 'flex' : 'none'; // Show/hide Layout group
            columnToggleGroup.style.display = showLayoutControls && currentColumnOrder !== 'default' ? 'flex' : 'none'; // Show/hide Column group

            // Ensure checklist is hidden if toggle button is hidden
            if (columnToggleButton.style.display === 'none') {
                 columnChecklist.classList.remove('visible');
            }


            // Render the appropriate view based on state only if there are results
            if(filteredAndSortedRequests.length > 0) {
                switch (currentView) {
                    case 'list':
                        renderList();
                        break;
                    case 'tile':
                        renderTiles();
                        break;
                    case 'detailed':
                    default:
                        renderTable();
                        break;
                }
            }
            updateViewSwitcherUI();
        }

        /** MODIFIED: Renders the Detailed Table View based on selected column order and visibility. */
        function renderTable() {
            requestsContentContainer.innerHTML = ''; // Clear container

            // CJ/kuys: If fetching paginated data from backend, totalItems might come from API response.
            const totalItems = filteredAndSortedRequests.length; // Use length of data *returned by API* for current filters
            const totalPages = Math.ceil(totalItems / itemsPerPage);
            if (currentPage > totalPages && totalPages > 0) currentPage = totalPages;
            if (currentPage < 1) currentPage = 1;

            // CJ/kuys: If fetching paginated data, paginatedRequests will be the array returned by the API.
            // The slicing below is frontend pagination and should be removed if backend handles it.
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const paginatedRequests = filteredAndSortedRequests.slice(startIndex, endIndex);

            const fragment = document.createDocumentFragment();
            const tableWrapper = document.createElement('div');
            tableWrapper.classList.add('table-container');
            tableWrapper.id = 'detailedTableWrapper';

            const table = document.createElement('table');
            table.classList.add('table-view');

            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');

            // Determine which columns to render based on layout and visibility
            let columnsToRender = [];
            if (currentColumnOrder === 'default') {
                columnsToRender = columnOrders.default; // Use fixed default order
            } else {
                // Start with the selected layout's order
                const baseOrder = columnOrders[currentColumnOrder] || columnOrders.requesterFirst; // Fallback to requesterFirst if invalid
                // Filter by visibility for non-default layouts
                columnsToRender = baseOrder.filter(colKey => {
                    const colDef = columnDefinitions[colKey];
                    return colDef && (!colDef.toggleable || visibleColumns.has(colKey));
                });
            }

            // Generate Header Row based on calculated order
            columnsToRender.forEach(colKey => {
                const colDef = columnDefinitions[colKey];
                if (!colDef) return;

                const th = document.createElement('th');
                th.classList.add('px-6', 'py-3', 'text-left', 'text-xs', 'font-medium', 'text-white', 'uppercase', 'tracking-wider');
                th.textContent = colDef.header;

                if (colDef.sortable) {
                    th.classList.add('sortable');
                    th.dataset.sort = colKey;
                    const icon = document.createElement('span');
                    icon.classList.add('sort-icon');
                    let iconClass = 'fa-solid fa-sort';
                    if (currentSort.column === colKey) {
                        th.classList.add(currentSort.direction === 'asc' ? 'sorted-asc' : 'sorted-desc');
                        iconClass = currentSort.direction === 'asc' ? 'fa-solid fa-sort-up' : 'fa-solid fa-sort-down';
                    }
                    icon.innerHTML = `<i class="${iconClass}"></i>`;
                    th.appendChild(icon);
                    th.addEventListener('click', () => handleSort(colKey));
                }
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);

            // Generate Table Body based on calculated order
            const tbody = document.createElement('tbody');
            tbody.classList.add('bg-white', 'divide-y', 'divide-gray-200');
            if (paginatedRequests.length === 0 && totalItems > 0) {
                tbody.innerHTML = `<tr><td colspan="${columnsToRender.length}" class="text-center py-4 text-gray-500">No requests on this page.</td></tr>`; // Dynamic colspan
            } else if (paginatedRequests.length === 0 && totalItems === 0) {
                // Handled by renderActiveView
            } else {
                paginatedRequests.forEach(request => {
                    const tr = document.createElement('tr');
                    tr.dataset.requestId = request.id;

                    columnsToRender.forEach(colKey => {
                        const colDef = columnDefinitions[colKey];
                        if (!colDef) return;

                        const td = document.createElement('td');
                        td.classList.add('px-6', 'py-4', 'whitespace-nowrap', 'text-sm');

                        let cellContent = getRequestData(request, colKey, 'N/A');
                        
                        // Special handling for book_title
                        if (colKey === 'book_title') {
                            cellContent = formatBookTitle(request);
                        }

                        // Apply specific formatting or classes
                        if (colDef.format) {
                            cellContent = colDef.format(cellContent, request);
                            td.innerHTML = cellContent; // Use innerHTML for formatted content like status/actions
                        } else {
                            td.textContent = cellContent;
                        }

                        // Add styling based on column key
                        if (colKey === 'id' || colKey === 'full_name' || colKey === 'document_id') {
                            td.classList.add('font-medium', 'text-gray-900');
                        } else if (colKey === 'affiliation') {
                            td.classList.add('text-gray-500', 'wrap-text');
                        } else if (colKey === 'actions') {
                            td.classList.add('actions-cell');
                        } else if (colKey !== 'status') { // Avoid double styling status
                            td.classList.add('text-gray-500');
                        }
                        // Apply truncation to book title cell
                        if (colKey === 'book_title') {
                            td.classList.add('truncate-cell');
                            td.title = formatBookTitle(request, true); // Use plain text for the tooltip
                        }

                        tr.appendChild(td);
                    });
                    tbody.appendChild(tr);
                });
            }

            table.appendChild(thead);
            table.appendChild(tbody);
            tableWrapper.appendChild(table);
            fragment.appendChild(tableWrapper);

            if (totalPages > 1) {
                fragment.appendChild(renderPaginationControls(totalPages));
            }

            requestsContentContainer.appendChild(fragment);
        }


        /** MODIFIED: Renders the Tile View with action dropdown and green header, truncates title, adds Document ID. */
        function renderTiles() {
            const container = document.createElement('div');
            container.classList.add('tile-view-container');
            filteredAndSortedRequests.forEach(request => {
                const tile = document.createElement('div');
                tile.classList.add('tile-item');
                tile.dataset.requestId = request.id;
                const status = getRequestData(request, 'status', 'pending');
                const statusClass = `status-${status}`;
                const statusText = status.charAt(0).toUpperCase() + status.slice(1);

                let statusOrActionHtml = '';
                if (status === 'pending') {
                    statusOrActionHtml = `
                        <select class="tile-action-dropdown status-pending" data-action="process" data-request-id="${request.id}">
                            <option value="" disabled selected>Pending</option>
                            <option value="approved">Approve</option>
                            <option value="rejected">Reject</option>
                        </select>`;
                } else {
                    statusOrActionHtml = `<span class="status-label ${statusClass}">${statusText}</span>`;
                }

                // Get title and author with our helper function
                const bookTitle = formatBookTitle(request);
                const authorName = getRequestData(request, 'author_name', 'Unknown');
                const volume = getRequestData(request, 'volume', '');
                const volumeText = volume && !getRequestData(request, 'is_compiled', false) ? `(Vol. ${volume})` : '';
                const documentId = getRequestData(request, 'document_id', 'N/A');
                const fullName = getRequestData(request, 'full_name', 'N/A');
                const affiliation = getRequestData(request, 'affiliation', 'N/A');
                const requestDate = getRequestData(request, 'created_at');
                
                // Get and format document URL 
                let docUrl = getRequestData(request, 'document_url', '');
                
                // Check if document URL is valid
                let documentLinkHtml = '';
                if (!docUrl || docUrl === '#' || docUrl === '/#') {
                    documentLinkHtml = `<p class="text-red-500 text-sm mt-1"><i class="fas fa-exclamation-circle mr-1"></i> Document not available</p>`;
                } else {
                    // Fix document URL if it's relative
                    if (!docUrl.startsWith('http') && !docUrl.startsWith('/')) {
                        docUrl = '/' + docUrl;
                    }
                    documentLinkHtml = `<a href="${docUrl}" target="_blank" class="view-doc-button" data-action="view" data-needs-auth="true" data-original-url="${docUrl}">View Document</a>`;
                }

                // Added title attribute to h3 for full title on hover
                tile.innerHTML = `
                    <div class="tile-header">
                        <span class="tile-request-id">ID: ${request.id}</span>
                        <h3 class="tile-title" title="${formatBookTitle(request, true)}">${bookTitle} ${volumeText}</h3>
                        <p class="tile-author">by ${authorName}</p>
                    </div>
                    <div class="tile-body">
                        <p><strong>Document ID:</strong> ${documentId}</p> 
                        <p class="tile-requester"><strong>Requester:</strong> ${fullName}</p>
                        <p><strong>Affiliation:</strong> <span class="wrap-text">${affiliation}</span></p>
                        <p><strong>Requested:</strong> ${formatDate(requestDate)}</p>
                        <div class="mt-2"> 
                            ${documentLinkHtml}
                        </div>
                     </div>
                    <div class="tile-actions">
                        ${statusOrActionHtml}
                    </div>`;
                container.appendChild(tile);
            });
            requestsContentContainer.appendChild(container);
            
            // Process document links to add auth tokens
            updateAllDocumentLinks();
        }

        /** MODIFIED: Renders the Expandable List View with subtle background/border, truncates title, adds Document ID. */
        function renderList() {
            const list = document.createElement('ul');
            list.classList.add('list-view-container');
            filteredAndSortedRequests.forEach(request => {
                const listItem = document.createElement('li');
                listItem.classList.add('list-item');
                
                const status = getRequestData(request, 'status', 'pending');
                const statusClass = `status-${status}`;
                const statusText = status.charAt(0).toUpperCase() + status.slice(1);
                
                // Get data with our helper function
                const fullName = getRequestData(request, 'full_name', 'N/A');
                const email = getRequestData(request, 'email', 'N/A');
                const affiliation = getRequestData(request, 'affiliation', 'N/A');
                const bookTitle = formatBookTitle(request);
                const authorName = getRequestData(request, 'author_name', 'Unknown');
                const volume = getRequestData(request, 'volume', '');
                const volumeText = volume && !getRequestData(request, 'is_compiled', false) ? `<span class="list-volume">(Vol. ${volume})</span>` : '';
                const documentId = getRequestData(request, 'document_id', 'N/A');
                const requestDate = getRequestData(request, 'created_at');
                const processedDate = getRequestData(request, 'reviewed_at');
                
                // Get and format document URL 
                let docUrl = getRequestData(request, 'document_url', '');
                
                // Check if document URL is valid
                let documentLinkHtml = '';
                if (!docUrl || docUrl === '#' || docUrl === '/#') {
                    documentLinkHtml = `<p class="text-red-500 text-sm mt-1"><i class="fas fa-exclamation-circle mr-1"></i> Document not available</p>`;
                } else {
                    // Fix document URL if it's relative
                    if (!docUrl.startsWith('http') && !docUrl.startsWith('/')) {
                        docUrl = '/' + docUrl;
                    }
                    documentLinkHtml = `<a href="${docUrl}" target="_blank" class="view-doc-button" data-action="view" data-needs-auth="true" data-original-url="${docUrl}">View</a>`;
                }

                const summary = document.createElement('div');
                summary.classList.add('list-item-summary');
                summary.dataset.requestId = request.id;

                let statusOrActionHtml = '';
                if (status === 'pending') {
                    statusOrActionHtml = `
                        <select class="list-action-dropdown status-pending" data-action="process" data-request-id="${request.id}">
                            <option value="" disabled selected>Pending</option>
                            <option value="approved">Approve</option>
                            <option value="rejected">Reject</option>
                        </select>`;
                } else {
                    statusOrActionHtml = `<span class="status-label ${statusClass}">${statusText}</span>`;
                }

                // Added title attribute to list-book-title span with plain text format
                summary.innerHTML = `
                    <div class="list-info">
                        <span class="list-request-id">ID: ${request.id}</span>
                        <span class="list-requester-name" title="${fullName}">${fullName}</span>
                        <span class="list-email" title="${email}">${email}</span>
                        <span class="list-affiliation" title="${affiliation}">${affiliation}</span>
                        <span class="list-book-title" title="${formatBookTitle(request, true)}">${bookTitle} ${volumeText}</span>
                        <span class="list-author">by ${authorName}</span>
                    </div>
                    <div class="list-actions">
                        ${statusOrActionHtml}
                        <span class="expand-icon"><i class="fas fa-chevron-down"></i></span>
                    </div>`;

                const details = document.createElement('div');
                details.classList.add('list-item-details');
                
                // Handle reasons (may be stored differently in DB)
                let reasonsHtml = '';
                if (Array.isArray(request.reasons)) {
                    reasonsHtml = request.reasons.map(r => `<span class="reason-tag-display">${r}</span>`).join('');
                } else if (request.reason) {
                    reasonsHtml = `<span class="reason-tag-display">${request.reason}</span>`;
                } else {
                    reasonsHtml = 'N/A';
                }
                
                // Handle reason details
                const reasonDetails = getRequestData(request, 'reason_details', '');
                const reasonDetailsHtml = ((Array.isArray(request.reasons) && request.reasons.includes('Other')) || 
                                          request.reason === 'Other') && reasonDetails 
                    ? `<p><strong>Reason Details:</strong><span class="reason-details-text">${reasonDetails}</span></p>` 
                    : '';
                    
                const processedAtHtml = processedDate 
                    ? `<p><strong>Processed At:</strong> ${formatDateTime(processedDate)}</p>` 
                    : '';
                    
                // ADDED: Display rejection reason if status is rejected
                const rejectionReasonHtml = (status === 'rejected' && request.review_notes)
                    ? `<p class="rejection-reason-display"><strong>Rejection Reason:</strong><br>${request.review_notes}</p>`
                    : '';

                details.innerHTML = `
                    <p><strong>Requester Name:</strong> ${fullName}</p>
                    <p><strong>Email:</strong> ${email}</p>
                    <p><strong>Affiliation:</strong> ${affiliation}</p>
                    <p><strong>Date Requested:</strong> ${formatDateTime(requestDate)}</p>
                    <hr class="my-2 border-gray-200">
                    <p><strong>Book Title:</strong> ${bookTitle}</p>
                    <p><strong>Author:</strong> ${authorName}</p>
                    ${volume ? `<p><strong>Volume:</strong> ${volume}</p>` : ''}
                    <p><strong>Document ID:</strong> ${documentId}</p> 
                    <div class="mt-2"> 
                        ${documentLinkHtml}
                    </div>
                    <hr class="my-2 border-gray-200">
                    <div class="mb-2">
                        <p class="mb-1"><strong>Reason(s):</strong></p>
                        <div class="reason-tags-display">${reasonsHtml}</div>
                    </div>
                    ${reasonDetailsHtml}
                    ${rejectionReasonHtml} 
                    ${processedDate ? '<hr class="my-2 border-gray-200">' : ''} 
                    ${processedAtHtml}
                    `;
                listItem.appendChild(summary);
                listItem.appendChild(details);
                list.appendChild(listItem);
            });
            requestsContentContainer.appendChild(list);
            
            // Process document links to add auth tokens
            updateAllDocumentLinks();
        }

        /** Creates and returns the pagination controls element with numbered buttons. */
        function renderPaginationControls(totalPages) { /* ... (same as before) ... */
            const controlsDiv = document.createElement('div');
            controlsDiv.classList.add('pagination-controls');
            controlsDiv.id = 'paginationControls';

            const prevButton = document.createElement('button');
            prevButton.id = 'prevPageBtn';
            prevButton.innerHTML = '&laquo;';
            prevButton.title = "Previous Page";
            prevButton.disabled = currentPage === 1;
            prevButton.addEventListener('click', () => goToPage(currentPage - 1));
            controlsDiv.appendChild(prevButton);

            const maxPagesToShow = 5;
            const halfMax = Math.floor(maxPagesToShow / 2);
            let startPage, endPage;
            if (totalPages <= maxPagesToShow) { startPage = 1; endPage = totalPages; } else if (currentPage <= halfMax) { startPage = 1; endPage = maxPagesToShow - 1; } else if (currentPage + halfMax >= totalPages) { startPage = totalPages - (maxPagesToShow - 2); endPage = totalPages; } else { startPage = currentPage - (halfMax - 1); endPage = currentPage + (halfMax - 1); }
            if (startPage > 1) { controlsDiv.appendChild(createPageButton(1)); if (startPage > 2) { controlsDiv.appendChild(createEllipsis()); } }
            for (let i = startPage; i <= endPage; i++) { if (i > 0 && i <= totalPages) { controlsDiv.appendChild(createPageButton(i)); } }
            if (endPage < totalPages) { if (endPage < totalPages - 1) { controlsDiv.appendChild(createEllipsis()); } controlsDiv.appendChild(createPageButton(totalPages)); }

            const nextButton = document.createElement('button');
            nextButton.id = 'nextPageBtn';
            nextButton.innerHTML = '&raquo;';
            nextButton.title = "Next Page";
            nextButton.disabled = currentPage === totalPages;
            nextButton.addEventListener('click', () => goToPage(currentPage + 1));
            controlsDiv.appendChild(nextButton);

            return controlsDiv;
        }

        /** Helper function to create a page number button. */
        function createPageButton(pageNumber) { /* ... (same as before) ... */
            const button = document.createElement('button');
            button.classList.add('page-number');
            button.textContent = pageNumber;
            button.dataset.page = pageNumber;
            if (pageNumber === currentPage) { button.classList.add('active'); button.disabled = true; } else { button.addEventListener('click', () => goToPage(pageNumber)); }
            return button;
        }

         /** Helper function to create an ellipsis element. */
        function createEllipsis() { /* ... (same as before) ... */
            const ellipsis = document.createElement('span');
            ellipsis.classList.add('ellipsis');
            ellipsis.textContent = '...';
            return ellipsis;
        }


        /** Navigates to a specific page in the detailed view. */
        function goToPage(pageNumber) {
            const totalPages = Math.ceil(filteredAndSortedRequests.length / itemsPerPage);
            if (pageNumber >= 1 && pageNumber <= totalPages) {
                currentPage = pageNumber;
                // CJ/kuys: If using backend pagination, this should trigger applyFiltersAndSort()
                // to fetch the new page data from the API.
                // If using frontend pagination (as currently implemented), just re-render the table.
                renderTable();
            }
        }

        /** Updates the active state of the view switcher buttons. */
        function updateViewSwitcherUI() { /* ... (same as before) ... */
             viewSwitcher.querySelectorAll('button').forEach(button => { button.classList.toggle('active', button.dataset.view === currentView); });
        }

        /** Handles clicking on a sortable table header. */
        function handleSort(columnKey) {
             if (currentView !== 'detailed') return;
             if (currentSort.column === columnKey) {
                 currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
             } else {
                 currentSort.column = columnKey;
                 currentSort.direction = 'asc';
             }
             // CJ/kuys: This should trigger applyFiltersAndSort() to fetch sorted data from backend.
             applyFiltersAndSort(); // This resets page to 1
        }

        /** MODIFIED: Opens the details modal, adds Document ID, shows rejection reason. */
        function openDetailsModal(requestId) {
            // Convert the requestId to match the database format (might be a number or string)
            const databaseId = typeof requestId === 'string' && !isNaN(parseInt(requestId)) ? parseInt(requestId) : requestId;
            console.log("[DEBUG] openDetailsModal: Looking for request with ID:", databaseId);
            
            // Find the request and be more flexible with the ID comparison
            const request = requests.find(req => {
                // Check for both number and string equality
                return req.id == databaseId || 
                       String(req.id) === String(databaseId);
            });
            
            if (!request) { 
                console.error("[DEBUG] Request not found:", requestId, "Available IDs:", requests.map(r => r.id)); 
                alert("Details not found."); 
                return; 
            }
            
            console.log("[DEBUG] Found request:", request);
            
            // Map database field names (snake_case) to frontend variables (camelCase) if needed
            detailRequestId.textContent = request.id || 'N/A'; 
            detailFullName.textContent = request.full_name || request.fullName || 'N/A'; 
            detailEmail.textContent = request.email || 'N/A'; 
            detailAffiliation.textContent = request.affiliation || 'N/A'; 
            
            // Handle book-related fields (may need to map from document data)
            detailBookTitle.textContent = formatBookTitle(request);
            detailAuthorName.textContent = request.author_name || request.authorName || 'N/A'; 
            
            // Only show volume separately if not a compiled document
            const isCompiled = getRequestData(request, 'is_compiled', false);
            detailVolume.textContent = isCompiled ? 'N/A' : (request.volume || 'N/A'); 
            
            // Handle URLs - Add authentication token to document URL
            let docUrl = request.document_url || request.documentUrl || '';
            
            // Set document link based on URL availability
            if (!docUrl || docUrl === '#' || docUrl === '/#') {
                // Document URL is missing or invalid - hide the link and show a message
                detailDocumentLink.style.display = 'none';
                
                // Check if we already created a message element
                let noDocMessage = modalDetailsContent.querySelector('#noDocumentMessage');
                if (!noDocMessage) {
                    noDocMessage = document.createElement('p');
                    noDocMessage.id = 'noDocumentMessage';
                    noDocMessage.className = 'text-red-500 text-sm mt-1';
                    noDocMessage.innerHTML = '<i class="fas fa-exclamation-circle mr-1"></i> Document not currently available';
                    
                    // Insert after the document link container
                    const viewButtonDiv = detailDocumentLink.parentElement;
                    if (viewButtonDiv) {
                        viewButtonDiv.appendChild(noDocMessage);
                    }
                } else {
                    noDocMessage.style.display = 'block';
                }
                
                console.log("[DEBUG] Document URL is missing or invalid:", docUrl);
            } else {
                // Fix document URL if it's relative (doesn't start with http or /)
                if (!docUrl.startsWith('http') && !docUrl.startsWith('/')) {
                    docUrl = '/' + docUrl;
                    console.log("[DEBUG] Converted relative URL to absolute:", docUrl);
                }
                
                // Show the link and hide any error message
                detailDocumentLink.style.display = 'inline-block';
                const noDocMessage = modalDetailsContent.querySelector('#noDocumentMessage');
                if (noDocMessage) {
                    noDocMessage.style.display = 'none';
                }
                
                // Set href and apply authentication
            detailDocumentLink.href = docUrl;
                detailDocumentLink.classList.add('view-doc-button');
                detailDocumentLink.setAttribute('target', '_blank');
                
                // Apply authentication to the link
            updateDocumentLink(detailDocumentLink, docUrl);
            }
            
            // Handle date fields
            const requestDate = request.created_at || request.requestedAt;
            detailRequestedAt.textContent = requestDate ? formatDateTime(requestDate) : 'N/A';
            
            // Handle reasons (may be stored differently in DB)
            if (Array.isArray(request.reasons)) {
                detailReasons.innerHTML = request.reasons.map(r => `<span class="reason-tag-display">${r}</span>`).join('') || 'None';
            } else if (request.reason) {
                // Single reason string from DB
                detailReasons.innerHTML = `<span class="reason-tag-display">${request.reason}</span>`;
            } else {
                detailReasons.innerHTML = 'None';
            }
            
            // Handle reason details
            const reasonDetails = request.reason_details || request.reasonDetails;
            if ((Array.isArray(request.reasons) && request.reasons.includes('Other') && reasonDetails) || 
                (request.reason === 'Other' && reasonDetails)) {
                detailReasonDetailsSection.classList.remove('hidden');
                detailReasonDetails.value = reasonDetails;
            } else {
                detailReasonDetailsSection.classList.add('hidden');
                detailReasonDetails.value = '';
            }
            
            // Handle status
            const status = request.status || 'pending';
            const statusClass = `status-${status}`; 
            const statusText = status.charAt(0).toUpperCase() + status.slice(1); 
            detailStatus.className = `status-label ${statusClass}`; 
            detailStatus.textContent = statusText;
            
            // Handle processed date
            const processedDate = request.reviewed_at || request.processedAt;
            if (processedDate) {
                detailProcessedAt.classList.remove('hidden');
                detailProcessedAt.querySelector('span').textContent = formatDateTime(processedDate);
            } else {
                detailProcessedAt.classList.add('hidden');
                detailProcessedAt.querySelector('span').textContent = '';
            }
            
            // Set up action buttons
            modalActions.innerHTML = '';
            if (status === 'pending') {
                modalActions.innerHTML = `<button class="approve-button modal-button">Approve</button><button class="reject-button modal-button">Reject</button>`;
                modalActions.querySelector('.approve-button').addEventListener('click', () => handleAction(request.id, 'approved'));
                modalActions.querySelector('.reject-button').addEventListener('click', () => handleAction(request.id, 'rejected'));
            } else {
                modalActions.innerHTML = `<p class="text-gray-600 font-medium">Request already ${status}.</p>`;
            }

            // Add Document ID to modal
            const existingDocIdP = modalDetailsContent.querySelector('#modalDocIdP');
             if (existingDocIdP) existingDocIdP.remove();
            const docIdElement = document.createElement('p');
            docIdElement.id = 'modalDocIdP';
            docIdElement.innerHTML = `<strong>Document ID:</strong> <span id="detailDocumentId">${request.document_id || request.documentId || 'N/A'}</span>`;
            const viewButtonDiv = detailDocumentLink.parentElement;
             if (viewButtonDiv) {
                modalDetailsContent.insertBefore(docIdElement, viewButtonDiv);
             } else {
                 modalDetailsContent.appendChild(docIdElement);
             }

             // Show/Hide Rejection Reason
            const rejectionReason = request.review_notes || request.rejectionReason;
            if (status === 'rejected' && rejectionReason) {
                detailRejectionReason.textContent = rejectionReason;
                 detailRejectionReasonSection.classList.remove('hidden');
             } else {
                 detailRejectionReasonSection.classList.add('hidden');
                 detailRejectionReason.textContent = '';
             }

            requestDetailsModal.classList.add('visible');
            
            console.log("[DEBUG] Modal opened with document URL:", docUrl);
        }

        /** Closes the details modal. */
        function closeDetailsModal() { /* ... (same as before) ... */
             requestDetailsModal.classList.remove('visible');
             // Remove dynamically added Document ID element
             const existingDocId = modalDetailsContent.querySelector('#modalDocIdP');
             if (existingDocId) {
                 existingDocId.remove();
             }
        }

         /** Opens the rejection reason modal */
         function openRejectionModal(requestId) {
            rejectionRequestIdInput.value = requestId;
            rejectModalRequestIdSpan.textContent = requestId;
            // Reset tags and textarea
            reasonTagsContainer.querySelectorAll('.reason-tag').forEach(tag => tag.classList.remove('active'));
            rejectionOtherReasonContainer.classList.add('hidden');
            rejectionOtherReasonText.value = '';
            rejectionOtherReasonText.required = false; // Reset required attribute

            rejectionReasonModal.classList.add('visible');
         }

         /** Closes the rejection reason modal */
         function closeRejectionModal() {
             rejectionReasonModal.classList.remove('visible');
             rejectionForm.reset(); // Reset the form (clears textarea)
             // Also manually clear active class from tags just in case
             reasonTagsContainer.querySelectorAll('.reason-tag').forEach(tag => tag.classList.remove('active'));
             rejectionOtherReasonContainer.classList.add('hidden');
         }

         /** MODIFIED: Handles submission of the rejection reason, closes main modal too. */
         async function submitRejection(event) {
            event.preventDefault();
             const requestId = rejectionRequestIdInput.value;
             const selectedTags = Array.from(reasonTagsContainer.querySelectorAll('.reason-tag.active'));
             const otherReasonText = rejectionOtherReasonText.value.trim();
             const isOtherSelected = !!reasonTagsContainer.querySelector('.reason-tag.active[data-reason="Other"]');

             let reason = selectedTags
                             .map(tag => tag.dataset.reason)
                .filter(reasonText => reasonText !== 'Other')
                             .join(', ');

             if (isOtherSelected) {
                 if (!otherReasonText) {
                     alert("Please specify a reason in the 'Other' text box.");
                     rejectionOtherReasonText.focus();
                     return;
                 }
                if (reason) {
                     reason += `, Other: ${otherReasonText}`;
                 } else {
                     reason = `Other: ${otherReasonText}`;
                 }
             }

            if (!reason) {
                 alert("Please select at least one reason or specify 'Other'.");
                 return;
             }

            try {
                // Get user info for authentication
                const userInfo = JSON.parse(sessionStorage.getItem('userInfo') || '{}');
                if (!userInfo.token) {
                    throw new Error('No authentication token found. Please log in again.');
                }

                // Send rejection through API
                const response = await fetch(`/api/document-requests/${requestId}/status`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${userInfo.token}`
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        status: 'rejected',
                        reviewedBy: userInfo.id || 'admin',
                        reviewNotes: reason
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Failed to reject request: ${response.status} ${errorText}`);
                }

                // Update local state
             const requestIndex = requests.findIndex(req => req.id === requestId);
                if (requestIndex !== -1) {
                 requests[requestIndex].status = 'rejected';
                    requests[requestIndex].rejectionReason = reason;
                 requests[requestIndex].processedAt = new Date().toISOString();

                    // Get the request with all updated information
                    const request = requests[requestIndex];
                    
                    console.log("[DEBUG] About to send rejection email for request:", request.id);
                    try {
                        const emailResult = await sendRejectionEmail(request, reason);
                        console.log("[DEBUG] Rejection email sending result:", emailResult);
                        
                        // Check if the emailResult indicates a network failure rather than API response
                        if (emailResult && emailResult.message && 
                            (emailResult.message.includes("Failed to fetch") || 
                             emailResult.message.includes("NetworkError"))) {
                            console.error("[DEBUG] Network error when sending email:", emailResult.message);
                            
                            // Try a second attempt with a different approach
                            try {
                                console.log("[DEBUG] Trying alternative rejection email method...");
                                const backupEmailResult = await fetch('/api/email/send-rejection', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        email: getRequestData(request, 'email', ''),
                                        fullName: getRequestData(request, 'full_name', 'User'),
                                        documentTitle: getRequestData(request, 'book_title', 'Document'),
                                        reason: reason,
                                        requestId: request.id,
                                        timestamp: new Date().toISOString(),
                                        debug: true
                                    })
                                });
                                
                                if (backupEmailResult.ok) {
                                    console.log("[DEBUG] Backup email method succeeded!");
                                    const backupData = await backupEmailResult.json();
                                    emailResult.success = backupData.success || true;
                                    emailResult.message = backupData.message || "Email sent via backup method";
                                }
                            } catch (backupError) {
                                console.error("[DEBUG] Backup email method also failed:", backupError);
                            }
                        }
                    } catch (emailError) {
                        console.error("[DEBUG] Rejection email sending error:", emailError);
                        // Continue with process even if email fails
                    }
                    
                    // Show the new dedicated rejection confirmation modal
                    const rejectionModal = document.getElementById('rejectionConfirmationModal');
                    const rejectionReasonDisplay = document.getElementById('rejectionReasonDisplay');
                    const rejectionEmailStatus = document.getElementById('rejectionEmailStatus');
                    const rejectionEmailMessage = document.getElementById('rejectionEmailMessage');
                    const rejectionConfirmationDetails = document.getElementById('rejectionConfirmationDetails');
                    
                    // Log visibility status of modal elements for debugging
                    console.log("[MODAL DEBUG] Modal elements found:", {
                        rejectionModal: !!rejectionModal,
                        rejectionReasonDisplay: !!rejectionReasonDisplay,
                        rejectionEmailStatus: !!rejectionEmailStatus,
                        rejectionEmailMessage: !!rejectionEmailMessage,
                        rejectionConfirmationDetails: !!rejectionConfirmationDetails
                    });
                    
                    // Set the rejection reason in the modal
                    rejectionReasonDisplay.textContent = reason;
                    
                    // Show email status based on the result
                    if (emailResult && emailResult.success) {
                        rejectionEmailStatus.classList.add('hidden');
                        rejectionConfirmationDetails.textContent = 'The requester has been notified by email of this rejection.';
                    } else {
                        rejectionEmailStatus.classList.remove('hidden');
                        rejectionEmailMessage.textContent = `There was an issue sending the email notification: ${emailResult?.message || 'Unknown error'}`;
                        rejectionConfirmationDetails.textContent = 'The request was rejected, but email notification could not be sent.';
                    }
                    
                    // Show the rejection confirmation modal with multiple methods to ensure visibility
                    rejectionModal.classList.add('visible');
                    rejectionModal.style.visibility = 'visible';
                    rejectionModal.style.opacity = '1';
                    rejectionModal.style.display = 'flex';
                    
                    console.log("[MODAL DEBUG] Made rejection modal visible");
                    
                    // Set a delayed check to verify modal is visible
                    setTimeout(() => {
                        const isVisible = window.getComputedStyle(rejectionModal).visibility === 'visible';
                        console.log(`[MODAL DEBUG] Modal visibility check after 100ms: ${isVisible ? 'VISIBLE' : 'HIDDEN'}`);
                        
                        if (!isVisible) {
                            // Force visibility with important declaration
                            rejectionModal.setAttribute('style', 
                                'visibility: visible !important; ' +
                                'opacity: 1 !important; ' +
                                'display: flex !important; ' +
                                'z-index: 2000 !important;'
                            );
                            console.log("[MODAL DEBUG] Applied forced visibility to modal");
                        }
                    }, 100);
                    
                    // Also show a simple notification
                    showConfirmationMessage(`Request ${requestId} rejected`, 'error');
                }
                
                 closeRejectionModal();
                closeDetailsModal();
                applyFiltersAndSort();
            } catch (error) {
                console.error('Error rejecting request:', error);
                showConfirmationMessage('Failed to reject request. Please try again.', 'error');
                
                // If it's an authentication error, show login button
                if (error.message.includes('authentication') || error.message.includes('permission')) {
                    requestsContentContainer.innerHTML = `
                        <div class="text-center text-red-600 py-4">
                            <p>Error: ${error.message}</p>
                            <button onclick="window.location.href='/log-in.html'" class="mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
                                Log in again
                            </button>
                        </div>`;
                }
            }
        }

        /**
         * Sends a rejection email notification to the requester
         * @param {Object} request - The rejected request object
         * @param {string} reason - The rejection reason
         */
        async function sendRejectionEmail(request, reason) {
            try {
                // Log debug info for email troubleshooting
                console.log(`[EMAIL DEBUG] ========== REJECTION EMAIL DEBUG ==========`);
                console.log(`[EMAIL DEBUG] Starting email process for request ID: ${request.id}`);
                console.log(`[EMAIL DEBUG] Request object:`, request);
                console.log(`[EMAIL DEBUG] Rejection reason:`, reason);
                
                // Get request details using our helper function
                const fullName = getRequestData(request, 'full_name', 'User');
                const email = getRequestData(request, 'email', '');
                const bookTitle = getRequestData(request, 'book_title', 'Document');
                
                console.log(`[EMAIL DEBUG] Extracted data: 
                  - Recipient: ${fullName} (${email})
                  - Document: ${bookTitle}
                  - Reason length: ${reason ? reason.length : 0} characters`);
                
                if (!email) {
                    console.error('[EMAIL DEBUG] ERROR: Cannot send rejection email - recipient email not found');
                    return { success: false, message: 'Missing recipient email' };
                }
                
                // Use the correct API endpoint for rejection emails
                const endpoints = [
                    '/api/email/send-rejection'
                ];
                
                let lastError = null;
                
                // Try each endpoint until one works
                for (const endpoint of endpoints) {
                    try {
                        console.log(`[EMAIL DEBUG] Attempting to send email via endpoint: ${endpoint}`);
                        
                        // Prepare request body
                        const requestBody = {
                            email,
                            fullName,
                            documentTitle: bookTitle,
                            reason,
                            requestId: request.id,
                            documentId: request.document_id || request.documentId,
                            debug: true,
                            timestamp: new Date().toISOString()
                        };
                        
                        console.log(`[EMAIL DEBUG] Request payload:`, requestBody);
                
                // Make API call to send the rejection email
                        console.log(`[EMAIL DEBUG]  MAKING FETCH CALL TO ${endpoint} with payload:`, requestBody);
                        
                        const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                            body: JSON.stringify(requestBody),
                            // Force no-cache to prevent caching issues
                            cache: 'no-cache'
                        });
                        
                        console.log(`[EMAIL DEBUG] API response status code: ${response.status}`);
                
                if (!response.ok) {
                    const errorText = await response.text();
                            console.error(`[EMAIL DEBUG] API error response: ${errorText}`);
                            
                            // Try to parse the error response if it's JSON
                            let errorDetail = errorText;
                            try {
                                const errorJson = JSON.parse(errorText);
                                errorDetail = errorJson.message || errorJson.error || errorText;
                            } catch (e) {
                                // Not JSON, use the text as is
                            }
                            
                            lastError = { 
                                success: false, 
                                endpoint,
                                status: response.status,
                                message: `API error: ${response.status} ${errorDetail.substring(0, 100)}`
                            };
                            
                            // Try next endpoint
                            continue;
                        }
                        
                        // Parse the response
                        try {
                            const responseData = await response.json();
                            console.log(`[EMAIL DEBUG] API response data:`, responseData);
                            
                            if (responseData.success) {
                                console.log(`[EMAIL DEBUG]  Email successfully sent to ${email} via ${endpoint}`);
                                return {
                                    ...responseData,
                                    endpoint
                                };
                            } else {
                                console.error(`[EMAIL DEBUG] API returned success=false:`, responseData);
                                lastError = {
                                    ...responseData,
                                    endpoint,
                                    status: response.status
                                };
                                
                                // Try next endpoint
                                continue;
                            }
                        } catch (parseError) {
                            console.error(`[EMAIL DEBUG] Error parsing API response:`, parseError);
                            
                            // If response was OK but couldn't parse as JSON, consider it a success
                            if (response.ok) {
                                console.log(`[EMAIL DEBUG]  Non-JSON success response from ${endpoint}`);
                                return { 
                                    success: true, 
                                    message: 'Email sent (non-JSON response)',
                                    endpoint 
                                };
                            } else {
                                lastError = { 
                                    success: false, 
                                    message: `Parse error: ${parseError.message}`,
                                    endpoint,
                                    status: response.status
                                };
                                
                                // Try next endpoint
                                continue;
                            }
                        }
                    } catch (endpointError) {
                        console.error(`[EMAIL DEBUG] Error with endpoint ${endpoint}:`, endpointError);
                        lastError = { 
                            success: false, 
                            message: `Endpoint error: ${endpointError.message}`,
                            endpoint
                        };
                        
                        // Try next endpoint
                        continue;
                    }
                }
                
                // If we get here, all endpoints failed
                console.error(`[EMAIL DEBUG]  All email endpoints failed. Last error:`, lastError);
                return lastError || { success: false, message: 'All email endpoints failed' };
                
            } catch (error) {
                console.error('[EMAIL DEBUG] Uncaught error sending rejection email:', error);
                return { 
                    success: false, 
                    message: error.message || 'Unknown error sending rejection email'
                };
            }
        }

        /** MODIFIED: Handles Approve/Reject action, opens rejection modal if needed. */
        async function handleAction(requestId, action) {
            try {
                console.log(`[DEBUG] handleAction: requestId=${requestId}, action=${action}`);
                
                // Convert requestId to appropriate format if needed
                const databaseId = typeof requestId === 'string' && !isNaN(parseInt(requestId)) 
                    ? parseInt(requestId, 10) 
                    : requestId;
                
                console.log(`[DEBUG] Using database ID: ${databaseId}`);
                
                // Get user info from sessionStorage
                const userInfo = JSON.parse(sessionStorage.getItem('userInfo') || '{}');
                if (!userInfo.token) {
                    throw new Error('No authentication token found. Please log in again.');
                }

                // Check if user is admin
                if (!userInfo.role || userInfo.role.toLowerCase() !== 'admin') {
                    throw new Error('You do not have permission to perform this action. Admin access required.');
                }

            if (action === 'rejected') {
                // Open the rejection reason modal instead of processing directly
                openRejectionModal(requestId);
            } else if (action === 'approved') {
                    // Process approval through API
                    console.log(`[DEBUG] Sending approval PATCH request to /api/document-requests/${databaseId}/status`);
                    
                    const response = await fetch(`/api/document-requests/${databaseId}/status`, {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${userInfo.token}`
                        },
                        credentials: 'include',
                        body: JSON.stringify({
                            status: 'approved',
                            reviewedBy: userInfo.id || 'admin',
                            reviewNotes: 'Approved by admin'
                        })
                    });

                    console.log(`[DEBUG] Response status: ${response.status}`);

                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error(`[DEBUG] Error response: ${errorText}`);
                        throw new Error(`Failed to approve request: ${response.status} ${errorText}`);
                    }

                    // Update local state - FIXED: Make ID comparison more flexible
                    const requestIndex = requests.findIndex(req => 
                        String(req.id) === String(requestId) || req.id == requestId
                    );
                    
                    console.log(`[DEBUG] Updating request at index: ${requestIndex}`);
                    
                    if (requestIndex !== -1) {
                    requests[requestIndex].status = 'approved';
                        requests[requestIndex].rejectionReason = null;
                    requests[requestIndex].processedAt = new Date().toISOString();
                        
                        // Get the request with all updated information
                        const request = requests[requestIndex];
                        
                        console.log("[DEBUG] Request approved - proceeding to send email");
                        
                        // Try to send the email
                        try {
                        const emailResult = await sendApprovalEmail(request);
                            console.log("[DEBUG] Email sending result:", emailResult);
                            
                            // Update the confirmation based on email result
                            if (emailResult && emailResult.success) {
                                // First show a simple confirmation message
                                showConfirmationMessage(`Request ${requestId} approved`, 'success');
                                
                                // Check if email is being processed in the background
                                if (emailResult.backgroundProcessing) {
                                    // Show confirmation for background processing
                                    setTimeout(() => {
                                        showDetailedConfirmation({
                                            message: `Request Approved`,
                                            details: `The request has been approved and an email notification is being processed. This will be sent shortly.`,
                                            type: 'success',
                                            fileStatus: 'processing'
                                        });
                                    }, 200);
                                } else {
                                    // Show confirmation based on file existence
                                    setTimeout(() => {
                                showDetailedConfirmation({
                                    message: `Email successfully sent`,
                                    details: emailResult.fileExists 
                                        ? `The approval email was sent with the document attached.` 
                                        : `The email was sent, but the document file could not be found.`,
                                    type: emailResult.fileExists ? 'success' : 'warning',
                                    fileStatus: emailResult.fileExists ? 'attached' : 'missing'
                                });
                                    }, 200);
                                }
                            } else {
                                // First show a simple confirmation message
                                showConfirmationMessage(`Request ${requestId} approved with email warning`, 'warning');
                                
                                // Then show the detailed popup with a slight delay
                                setTimeout(() => {
                                showDetailedConfirmation({
                                    message: `Email issue`,
                                    details: `The request was approved, but there may have been an issue sending the notification email.`,
                                    type: 'warning',
                                    fileStatus: 'uncertain'
                                });
                                }, 200);
                            }
                        } catch (emailError) {
                            console.error("[DEBUG] Error in email sending:", emailError);
                            
                            // First show a simple confirmation message
                            showConfirmationMessage(`Request ${requestId} approved but email failed`, 'error');
                            
                            // Then show the detailed popup with a slight delay
                            setTimeout(() => {
                            showDetailedConfirmation({
                                message: `Email error`,
                                details: `The request was approved, but there was an error sending the notification: ${emailError.message}`,
                                type: 'error',
                                fileStatus: 'failed'
                            });
                            }, 200);
                        }
                    }

                    closeDetailsModal();
                    applyFiltersAndSort();
                }
            } catch (error) {
                console.error('Error handling request action:', error);
                showConfirmationMessage(`Failed to ${action} request: ${error.message}`, 'error');
                
                // If it's an authentication error, show login button
                if (error.message.includes('authentication') || error.message.includes('permission')) {
                    requestsContentContainer.innerHTML = `
                        <div class="text-center text-red-600 py-4">
                            <p>Error: ${error.message}</p>
                            <button onclick="window.location.href='/log-in.html'" class="mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
                                Log in again
                            </button>
                        </div>`;
                }
            }
        }

        /** * Sends an approval email with the PDF document attached * @param {Object} request - The approved request object * @returns {Promise<object|boolean>} - The result from the email service */
        async function sendApprovalEmail(request) {
            try {
                // Log the request object to help diagnose fields
                console.log(`[DOCUMENT REQUEST] Starting email process for approval of request:`, request);
                
                // Get request details
                const fullName = getRequestData(request, 'full_name', 'User');
                const email = getRequestData(request, 'email', '');
                const bookTitle = getRequestData(request, 'book_title', 'Document');
                
                // Get document ID using multiple possible field names
                let documentId = null;
                const potentialIdFields = ['document_id', 'documentId', 'doc_id', 'bookId'];
                for (const field of potentialIdFields) {
                    if (request[field] && !isNaN(parseInt(request[field]))) {
                        documentId = request[field];
                        console.log(`[DOCUMENT REQUEST] Found document ID in field '${field}': ${documentId}`);
                        break;
                    }
                }
                
                // Fallbacks for document ID
                if (!documentId) {
                    if (request.id && !isNaN(parseInt(request.id))) {
                        documentId = request.id;
                        console.log(`[DOCUMENT REQUEST] Using request.id as document ID (fallback): ${documentId}`);
                    } else if (request.documentUrl) {
                        const urlParts = request.documentUrl.split('/');
                        const lastPart = urlParts[urlParts.length - 1];
                        if (!isNaN(parseInt(lastPart))) {
                            documentId = lastPart;
                            console.log(`[DOCUMENT REQUEST] Extracted document ID from URL: ${documentId}`);
                        }
                    }
                }
                
                console.log(`[DOCUMENT REQUEST] Final document ID for email attachment: ${documentId}`);
                
                if (!email) {
                    console.error('[DOCUMENT REQUEST] Cannot send approval email: recipient email not found');
                    return { success: false, message: 'Missing recipient email' };
                }
                        
                if (!documentId) {
                    console.error('[DOCUMENT REQUEST] Missing document ID for email attachment');
                    return { success: false, message: 'Missing document ID', fileExists: false };
                }
                
                // Call email API
                console.log(`[DOCUMENT REQUEST] Calling email API to send document ID ${documentId} to ${email}`);
                
                // Create request body with debugging flag
                const requestBody = {
                    email,
                    fullName,
                    documentTitle: bookTitle,
                    documentId,
                    requestId: request.id,
                    debug: true,
                    forceAttachment: true,
                    checkAllDirectories: true
                };
                
                // Check for child documents (for entire collection requests)
                if (request.child_documents && Array.isArray(request.child_documents) && request.child_documents.length > 0) {
                    console.log(`[DOCUMENT REQUEST] Request includes ${request.child_documents.length} child documents`);
                    requestBody.childDocumentIds = request.child_documents;
                    requestBody.isEntireCollection = true;
                } else if (request.is_entire_collection || request.isEntireCollection) {
                    console.log(`[DOCUMENT REQUEST] Request is for entire collection, but no child documents found. Will attempt to fetch them.`);
                    requestBody.isEntireCollection = true;
                }
                
                console.log(`[DOCUMENT REQUEST] Email API request body:`, requestBody);
                
                // Call the API
                const response = await fetch('/api/email/send-approval', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                console.log(`[DOCUMENT REQUEST] Email API response status:`, response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`[DOCUMENT REQUEST] Email API error: ${errorText}`);
                    return { 
                        success: false, 
                        message: `API error: ${response.status} ${errorText.substring(0, 100)}`,
                        fileExists: false
                    };
                }
                
                // Parse the response
                const responseData = await response.json();
                console.log(`[DOCUMENT REQUEST] Email API response:`, responseData);
                
                // Check if this is a background job response
                if (responseData.backgroundProcessing) {
                    console.log(`[DOCUMENT REQUEST] Email is being processed in the background (Job ID: ${responseData.jobId})`);
                    
                    // Add job ID to response for potential future status checks
                    return {
                        success: true,
                        backgroundProcessing: true,
                        jobId: responseData.jobId,
                        fileExists: responseData.fileExists || false,
                        message: "Email is being processed in the background",
                        documentPath: responseData.documentPath || ''
                    };
                }
                
                // Handle regular synchronous response
                if (responseData.success !== undefined) {
                    // Make sure we always have a fileExists property
                    if (responseData.fileExists === undefined) {
                        // Check for indirect indicators that a file was attached
                        responseData.fileExists = 
                            responseData.documentPath || 
                            responseData.attachment_success || 
                            (responseData.fileSize && responseData.fileSize > 0) || 
                            false;
                    }
                    
                    // Log what we're returning
                    console.log(`[DOCUMENT REQUEST] Returning response with fileExists=${responseData.fileExists}:`, responseData);
                    
                    return responseData;
                } else {
                    // Construct our own response from whatever the API returned
                    const result = {
                        success: true,
                        fileExists: responseData.fileExists || 
                                    responseData.documentPath || 
                                    responseData.attachment_success || 
                                    (responseData.fileSize && responseData.fileSize > 0) || 
                                    false,
                        documentPath: responseData.documentPath || '',
                        message: responseData.message || 'Email sent successfully'
                    };
                    
                    // Log what we're returning
                    console.log(`[DOCUMENT REQUEST] Constructed response with fileExists=${result.fileExists}:`, result);
                    
                    return result;
                }
            } catch (error) {
                console.error('[DOCUMENT REQUEST] Error sending approval email:', error);
                return { 
                    success: false, 
                    message: error.message || 'Unknown error sending email',
                    fileExists: false,
                    fileStatus: 'failed'
                };
            }
        }

        /**
         * DEPRECATED: This function has been replaced by sendApprovalEmail and sendRejectionEmail
         * which use the email API endpoints.
         */
        function sendNotificationEmail(request, type) {
            console.log(`This function is deprecated. Use sendApprovalEmail or sendRejectionEmail instead.`);
        }


        /** MODIFIED: Shows a confirmation message with different styles. */
        function showConfirmationMessage(message, type = 'success') { // Default to 'success'
             confirmationMessage.textContent = message;
             // Remove previous type classes
             confirmationMessage.classList.remove('success', 'error', 'warning');
             // Add the new type class
             confirmationMessage.classList.add(type);
             // Make visible
             confirmationMessage.classList.add('visible');
             // Hide after timeout
             setTimeout(() => { confirmationMessage.classList.remove('visible'); }, 3000);
        }

         /** Populates the column visibility checklist */
        function renderColumnVisibilityControl() {
            columnChecklist.innerHTML = ''; // Clear existing items
            const baseOrder = columnOrders[currentColumnOrder] || columnOrders.requesterFirst; // Use a full layout for checklist items

            baseOrder.forEach(colKey => {
                const colDef = columnDefinitions[colKey];
                // Only include toggleable columns in the checklist
                if (colDef && colDef.toggleable) {
                    const li = document.createElement('li');
                    const label = document.createElement('label');
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = colKey;
                    checkbox.checked = visibleColumns.has(colKey);
                    checkbox.addEventListener('change', handleColumnVisibilityChange);

                    label.appendChild(checkbox);
                    label.appendChild(document.createTextNode(` ${colDef.header}`)); // Add space
                    li.appendChild(label);
                    columnChecklist.appendChild(li);
                }
            });
             // Show/hide based on current layout and view
             columnToggleButton.style.display = (currentColumnOrder === 'default' || currentView !== 'detailed') ? 'none' : 'inline-flex';
        }

        /** Handles changes in column visibility checkboxes */
        function handleColumnVisibilityChange(event) {
            const colKey = event.target.value;
            if (event.target.checked) {
                visibleColumns.add(colKey);
            } else {
                visibleColumns.delete(colKey);
            }
            saveVisibleColumns(); // Save the new set
            if (currentView === 'detailed') {
                renderTable(); // Re-render the table with updated visibility
            }
        }


        // --- Event Listeners ---

        // Filter dropdown change
        statusFilterSelect.addEventListener('change', (event) => {
            currentFilter = event.target.value;
            applyFiltersAndSort();
        });

        // Date Range Button Click
        dateRangeButton.addEventListener('click', () => {
            // Populate modal inputs with current filter values
            modalStartDateInput.value = startDateFilter;
            modalEndDateInput.value = endDateFilter;
            dateRangeModal.classList.add('visible');
        });

        // Date Range Modal Close/Cancel
        closeDateRangeModalButton.addEventListener('click', () => dateRangeModal.classList.remove('visible'));
        cancelDateRangeButton.addEventListener('click', () => dateRangeModal.classList.remove('visible'));
        dateRangeModal.addEventListener('click', (event) => { if (event.target === dateRangeModal) dateRangeModal.classList.remove('visible'); });

         // Date Range Modal Apply
        dateRangeForm.addEventListener('submit', (event) => {
            event.preventDefault();
            startDateFilter = modalStartDateInput.value;
            endDateFilter = modalEndDateInput.value;
            dateRangeModal.classList.remove('visible');
            // Update button text
            if (startDateFilter || endDateFilter) {
                dateRangeButtonText.textContent = `${startDateFilter || '...'} - ${endDateFilter || '...'}`;
            } else {
                dateRangeButtonText.textContent = 'Date Range';
            }
            applyFiltersAndSort();
        });


        // Column Order Select change
        columnOrderSelect.addEventListener('change', (event) => {
            currentColumnOrder = event.target.value;
            saveColumnOrder(); // Save preference
            renderColumnVisibilityControl(); // Re-render checklist and show/hide button
            if (currentView === 'detailed') {
                renderTable(); // Re-render table immediately if in detailed view
            }
        });

        // Column Toggle Button click
        columnToggleButton.addEventListener('click', (event) => {
             event.stopPropagation(); // Prevent body click listener from closing it immediately
             columnChecklist.classList.toggle('visible');
        });

        // Search input changes (with debounce)
        searchInput.addEventListener('input', (event) => {
            clearTimeout(searchInput.timer);
            searchInput.timer = setTimeout(() => {
                currentSearchTerm = event.target.value;
                applyFiltersAndSort();
            }, 300);
        });

        // View Switcher clicks
        viewSwitcher.addEventListener('click', (event) => {
            const button = event.target.closest('button');
            if (button && button.dataset.view) {
                const newView = button.dataset.view;
                if (newView !== currentView) {
                    currentView = newView;
                    applyFiltersAndSort(); // This resets page and renders correct view
                }
            }
        });

        // Event delegation for clicks within the content container
        requestsContentContainer.addEventListener('click', (event) => {
            const targetElement = event.target;
            const viewButton = targetElement.closest('a.view-doc-button');
            const actionButton = targetElement.closest('button[data-action]'); // Keep for modal potentially
            const pageButton = targetElement.closest('.pagination-controls button, .pagination-controls .page-number');

            // Check for "View Document" button click
            if (viewButton && viewButton.dataset.action === 'view') {
                event.stopPropagation();
                return;
            }

            // Check for List Item Summary click (for expanding/collapsing)
            const summaryElement = targetElement.closest('.list-item-summary');
             if (currentView === 'list' && summaryElement && !targetElement.closest('select.list-action-dropdown')) {
                if (targetElement.closest('a, button')) return;
                summaryElement.parentElement.classList.toggle('expanded');
                return;
            }

            // Check for Tile or Table Row click (for opening modal)
            const clickableItem = targetElement.closest('.tile-item[data-request-id], tr[data-request-id]');
            if (clickableItem && clickableItem.dataset.requestId && !viewButton && !actionButton && !targetElement.closest('select') && !pageButton) {
                 openDetailsModal(clickableItem.dataset.requestId);
            }

            // Note: Clicks on pagination buttons are handled by their individual listeners
        });

        // Event listener for 'change' events specifically for the action dropdowns
        requestsContentContainer.addEventListener('change', (event) => {
            const targetElement = event.target;
            // Check for List view dropdown OR Tile view dropdown OR Table view dropdown
            if (targetElement.matches('select.list-action-dropdown, select.tile-action-dropdown, .table-view select[data-action="process"]') && targetElement.dataset.action === 'process') {
                event.stopPropagation(); // Prevent summary click/toggle or modal open
                const action = targetElement.value;
                const requestId = targetElement.dataset.requestId;
                
                console.log(`[DEBUG] Dropdown changed: action=${action}, requestId=${requestId}`);
                
                // Find the request - FIXED: Use loose equality for ID comparison
                const requestIndex = requests.findIndex(req => 
                    String(req.id) === String(requestId) || req.id == requestId
                );
                
                console.log(`[DEBUG] Found request at index: ${requestIndex}`);
                
                if (action && requestId && requestIndex !== -1) {
                    // Get the full request object to have complete data
                    const request = requests[requestIndex];
                    
                    // For both approval and rejection, directly call handleAction without opening the details modal
                    handleAction(requestId, action);
                } else {
                    console.error(`[ERROR] Invalid selection: action=${action}, requestId=${requestId}, found=${requestIndex !== -1}`);
                }
                
                // Reset dropdown back to 'Pending' after selection (for better UX)
                if (targetElement.tagName === 'SELECT') {
                    targetElement.value = "";
                }
            }
        });

        // Close column checklist if clicking outside
        document.addEventListener('click', (event) => {
            if (columnChecklist.classList.contains('visible') && !columnToggleButton.contains(event.target) && !columnChecklist.contains(event.target)) {
                columnChecklist.classList.remove('visible');
            }
        });


        // Modal close listeners (remain the same)
        closeDetailsModalButton.addEventListener('click', closeDetailsModal);
        requestDetailsModal.addEventListener('click', (event) => { if (event.target === requestDetailsModal) closeDetailsModal(); });
        document.addEventListener('keydown', (event) => { if (event.key === 'Escape' && requestDetailsModal.classList.contains('visible')) closeDetailsModal(); });

        // Rejection Modal Listeners
        closeRejectionModalButton.addEventListener('click', closeRejectionModal);
        cancelRejectionButton.addEventListener('click', closeRejectionModal);
        rejectionReasonModal.addEventListener('click', (event) => { if (event.target === rejectionReasonModal) closeRejectionModal(); });
        rejectionForm.addEventListener('submit', submitRejection);

        // Add listener for rejection reason tags
         reasonTagsContainer.addEventListener('click', (event) => {
             if (event.target.classList.contains('reason-tag')) {
                 const tag = event.target;
                 tag.classList.toggle('active');
                 const reason = tag.dataset.reason;
                 if (reason === 'Other') {
                     rejectionOtherReasonContainer.classList.toggle('hidden', !tag.classList.contains('active'));
                     rejectionOtherReasonText.required = tag.classList.contains('active'); // Make required if Other is selected
                     if (tag.classList.contains('active')) {
                         rejectionOtherReasonText.focus();
                     } else {
                         rejectionOtherReasonText.value = ''; // Clear if deselected
                     }
                 }
             }
         });


        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', function() {
            console.log('[Init] Document permissions page loading');
            
            // Check for authentication errors
            const authOk = handlePageErrors();
            
            // Initialize document links with authentication even if auth check fails
            setTimeout(initDocumentLinks, 500); // Small delay to ensure DOM is fully loaded
            
            // Add event listeners for the rejection confirmation modal
            const rejectionConfirmationModal = document.getElementById('rejectionConfirmationModal');
            const closeRejectionConfirmationModalButton = document.getElementById('closeRejectionConfirmationModalButton');
            const rejectionConfirmationCloseButton = document.getElementById('rejectionConfirmationCloseButton');
            
            // Close modal when X button is clicked
            if (closeRejectionConfirmationModalButton) {
                closeRejectionConfirmationModalButton.addEventListener('click', () => {
                    rejectionConfirmationModal.classList.remove('visible');
                });
            }
            
            // Close modal when Close button is clicked
            if (rejectionConfirmationCloseButton) {
                rejectionConfirmationCloseButton.addEventListener('click', () => {
                    rejectionConfirmationModal.classList.remove('visible');
                });
            }
            
            // Close modal when clicking outside
            if (rejectionConfirmationModal) {
                rejectionConfirmationModal.addEventListener('click', (event) => {
                    if (event.target === rejectionConfirmationModal) {
                        rejectionConfirmationModal.classList.remove('visible');
                    }
                });
            }
            
            // Load the rest of the page content even if auth fails
            // This allows viewing the UI even without full permissions
            fetch('./side_bar.html')
                .then(response => response.text())
                .then(data => {
                    document.getElementById('sidebar-container').innerHTML = data;
                    
                    // Initialize sidebar functionality after loading
                    if (typeof highlightActiveSidebarLink === 'function') {
                      highlightActiveSidebarLink();
                    }
                    
                    // Setup logout if it exists
                    if (typeof setupLogout === 'function') {
                      setupLogout();
                    }
                })
                .catch(error => console.error('Error loading sidebar:', error));
    
            fetch('./navbar_header.html')
                .then(response => response.text())
                .then(data => {
                    document.getElementById('navbar-header').innerHTML = data;
                })
                .catch(error => console.error('Error loading navbar:', error));
            
            // Try to load data, but don't block UI if it fails
            if (authOk) {
             loadingMessage.style.display = 'none';
                loadData().catch(error => {
                    console.error('[Init] Error loading request data:', error);
                    
                    // Show a message but don't redirect to login immediately
                    requestsContentContainer.innerHTML = `
                        <div class="text-center text-orange-600 py-4">
                            <p>Some features may be limited due to authentication issues.</p>
                            <p class="text-sm mt-2">${error.message}</p>
                            <button id="tryAuthAgainBtn" class="mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
                                Authenticate
                            </button>
                        </div>`;
                        
                    document.getElementById('tryAuthAgainBtn')?.addEventListener('click', function() {
                        window.location.href = '/log-in.html';
                    });
                });
            } else {
                // Auth already failed, but we'll still show parts of the UI
                loadingMessage.style.display = 'none';
            }
        });
        
        // Function to initialize all document links with authentication tokens
        function initDocumentLinks() {
            console.log('[Document Links] Initializing document link authentication');
            
            // Process any existing links first
            updateAllDocumentLinks();
            
            // Set up a mutation observer to add auth tokens to document links added dynamically
            const observer = new MutationObserver((mutations) => {
                mutations.forEach(mutation => {
                    if (mutation.type === 'childList') {
                        mutation.addedNodes.forEach(node => {
                            if (node.nodeType === 1) { // Element node
                                // Check if the node itself is a link that needs auth
                                if ((node.classList && node.classList.contains('view-doc-button') || 
                                     node.hasAttribute('data-needs-auth')) && 
                                    !node.hasAttribute('data-auth-processed')) {
                                    updateDocumentLink(node, node.getAttribute('href'));
                                    node.setAttribute('data-auth-processed', 'true');
                                }
                                
                                // Check for links inside the added node
                                const links = node.querySelectorAll('a.view-doc-button, a[data-needs-auth="true"]');
                                links.forEach(link => {
                                    if (!link.hasAttribute('data-auth-processed')) {
                                        updateDocumentLink(link, link.getAttribute('href'));
                                        link.setAttribute('data-auth-processed', 'true');
                                    }
                                });
                            }
                        });
                    }
                });
            });
            
            // Start observing the document with the configured parameters
            observer.observe(document.body, { childList: true, subtree: true });
            console.log('[Document Links] Observer set up for document links');
            
            // Set a periodic check for links that need updating
            setInterval(updateAllDocumentLinks, 30000); // Check every 30 seconds
            
            // Try to refresh the token once at startup
            refreshAuthToken().then(newToken => {
                if (newToken) {
                    // If we got a new token, update all links
                    updateAllDocumentLinks();
                }
            });
        }
        
        // Helper function to update all document links
        function updateAllDocumentLinks() {
            console.log('[Document Links] Updating all document links');
            
            // Reduce verbosity with a counter
            let updatedCount = 0;
            let skippedCount = 0;
            
            // Process all view-doc-button links and data-needs-auth links
            document.querySelectorAll('a.view-doc-button, a[data-needs-auth="true"]').forEach(link => {
                // Get the original URL, falling back to href if needed
                const originalUrl = link.getAttribute('data-original-url') || link.href;
                
                // Don't process empty links or javascript: links
                if (!originalUrl || originalUrl === '#' || originalUrl === '/#' || originalUrl.startsWith('javascript:')) {
                    skippedCount++;
                    return;
                }
                
                // Remove protocols and domain from href when comparing to avoid false differences
                const cleanHref = link.href.replace(/^https?:\/\/[^\/]+/, '');
                const cleanOriginal = originalUrl.replace(/^https?:\/\/[^\/]+/, '');
                
                // Skip links that already have auth tokens and contain the original URL
                if ((cleanHref.includes('auth_token=') || cleanHref.includes('use_cookie_auth=')) && 
                    cleanHref.includes(cleanOriginal)) {
                    skippedCount++;
                    return;
                }
                
                // Update the link
                updateDocumentLink(link, originalUrl);
                link.setAttribute('data-auth-processed', 'true');
                updatedCount++;
            });
            
            if (updatedCount > 0 || skippedCount > 0) {
                console.log(`[Document Links] Updated ${updatedCount} links, skipped ${skippedCount}`);
            }
        }

        /** 
         * Formats the book title based on document type, specifically handling compiled documents 
         * For compiled documents, displays as (category type, volume no, issue no, 
         * dept table for SYNERGY, start and end year)
         * @param {Object} request - The request object containing document data
         * @param {boolean} plainText - Whether to return plain text (true) or HTML (false)
         * @returns {string} Formatted title with appropriate styling
         */
        function formatBookTitle(request, plainText = false) {
            // Check if the document is compiled
            const isCompiled = getRequestData(request, 'is_compiled', false);
            
            // If not compiled, just return the regular title
            if (!isCompiled) {
                return getRequestData(request, 'book_title', 'N/A');
            }
            
            // For compiled documents, format according to the specification
            const documentType = getRequestData(request, 'document_type', '').toUpperCase();
            const categoryType = getRequestData(request, 'category', documentType);
            const volume = getRequestData(request, 'volume', '');
            const issueNo = getRequestData(request, 'issue', '');
            const startYear = getRequestData(request, 'start_year', '');
            const endYear = getRequestData(request, 'end_year', '');
            const department = getRequestData(request, 'department', '');
            
            // Build parts of the title
            const parts = [];
            
            // First add category type
            parts.push(categoryType || 'Document');
            
            // Add volume if available
            if (volume) {
                parts.push(`Vol. ${volume}`);
            }
            
            // Add issue if available
            if (issueNo) {
                parts.push(`Issue ${issueNo}`);
            }
            
            // For Synergy, add department info
            if (documentType === 'SYNERGY' && department) {
                parts.push(department);
            }
            
            // Create the base title with comma separation
            let formattedTitle = parts.join(', ');
            
            // Add years as a suffix in parentheses if available
            if (startYear && endYear) {
                formattedTitle += ` (${startYear}-${endYear})`;
            } else if (startYear) {
                formattedTitle += ` (${startYear})`;
            } else if (endYear) {
                formattedTitle += ` (${endYear})`;
            }
            
            // Use appropriate format based on context
            if (plainText) {
                // Plain text version for contexts where HTML won't work
                return `[Compiled] ${formattedTitle}`;
            } else {
                // HTML version with a badge for rich contexts
                return `<span style="display: inline-flex; align-items: center;"><span style="background-color: #e0f2fe; color: #0369a1; font-size: 0.75rem; padding: 0.125rem 0.5rem; border-radius: 9999px; margin-right: 0.5rem; font-weight: 600;">COMPILED</span>${formattedTitle}</span>`;
            }
        }

        /** Handles page errors and automatically refreshes authentication if needed */
        function handlePageErrors() {
            // Check for authentication token using our helper function
            const token = getAuthToken();
            if (!token) {
                console.warn('[Auth] No authentication token found. Showing login prompt.');
                
                // Try to refresh token before showing login prompt
                refreshAuthToken().then(newToken => {
                    if (newToken) {
                        console.log('[Auth] Authentication refreshed successfully on page load');
                        // Reload the page to use the new token
                        window.location.reload();
                    } else {
                        showLoginPrompt();
                    }
                });
                
                return false;
            }
            
            // Set up global error handler for fetch requests
            window.addEventListener('unhandledrejection', function(event) {
                console.error('[Error] Unhandled promise rejection:', event.reason);
                
                // Check if it's an auth error
                if (event.reason && typeof event.reason === 'object') {
                    const errorText = event.reason.message || String(event.reason);
                    if (
                        errorText.includes('authentication') || 
                        errorText.includes('token') || 
                        errorText.includes('unauthorized') ||
                        errorText.includes('permission')
                    ) {
                        console.warn('[Auth] Authentication issue detected:', errorText);
                        
                        // Try to refresh token first
                        refreshAuthToken().then(newToken => {
                            if (newToken) {
                                console.log('[Auth] Successfully refreshed token after error');
                                // Reload the page to use the new token
                                window.location.reload();
                            } else {
                                showLoginPrompt();
                            }
                        });
                    }
                }
            });
            
            // All checks passed
            return true;
        }

        /** Shows a login prompt when authentication fails */
        function showLoginPrompt() {
            // Create a login prompt overlay
            let overlay = document.getElementById('authentication-overlay');
            
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'authentication-overlay';
                overlay.style.position = 'fixed';
                overlay.style.top = '0';
                overlay.style.left = '0';
                overlay.style.width = '100%';
                overlay.style.height = '100%';
                overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                overlay.style.display = 'flex';
                overlay.style.alignItems = 'center';
                overlay.style.justifyContent = 'center';
                overlay.style.zIndex = '2000';
                
                const loginBox = document.createElement('div');
                loginBox.style.backgroundColor = 'white';
                loginBox.style.padding = '2rem';
                loginBox.style.borderRadius = '0.5rem';
                loginBox.style.maxWidth = '400px';
                loginBox.style.width = '90%';
                loginBox.style.textAlign = 'center';
                
                loginBox.innerHTML = `
                    <h2 style="color: #047857; margin-bottom: 1rem;">Authentication Required</h2>
                    <p style="margin-bottom: 1.5rem;">Your session has expired or you are not logged in. Please log in again to continue.</p>
                    <button id="loginRedirectBtn" style="background-color: #047857; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 0.375rem; cursor: pointer; font-weight: bold;">Log In</button>
                    <button id="closeAuthOverlayBtn" style="background-color: #6B7280; color: white; border: none; padding: 0.75rem 1rem; border-radius: 0.375rem; margin-left: 0.5rem; cursor: pointer;">Cancel</button>
                `;
                
                overlay.appendChild(loginBox);
                document.body.appendChild(overlay);
                
                document.getElementById('loginRedirectBtn').addEventListener('click', function() {
                    window.location.href = '/log-in.html';
                });
                
                document.getElementById('closeAuthOverlayBtn').addEventListener('click', function() {
                    document.getElementById('authentication-overlay').remove();
                });
            } else {
                // If overlay already exists, just show it
                overlay.style.display = 'flex';
            }
        }

        /** Helps get data from a request object, checking both snake_case (DB) and camelCase (frontend) naming */
        function getRequestData(request, key, fallback = 'N/A') {
            if (!request) {
                console.error("[DEBUG] getRequestData called with null/undefined request");
                return fallback;
            }
            
            // First check for exact key match
            if (request[key] !== undefined) {
                return request[key];
            }
            
            // Then check for snake_case to camelCase conversion (e.g., full_name  fullName)
            const camelKey = key.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
            if (request[camelKey] !== undefined) {
                return request[camelKey];
            }
            
            // Then check for camelCase to snake_case conversion (e.g., fullName  full_name)
            const snakeKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
            if (request[snakeKey] !== undefined) {
                return request[snakeKey];
            }
            
            // Specific mappings for known fields
            const knownMappings = {
                'created_at': 'requestedAt',
                'requestedAt': 'created_at',
                'reviewed_at': 'processedAt',
                'processedAt': 'reviewed_at',
                'document_id': 'documentId',
                'documentId': 'document_id',
                'full_name': 'fullName',
                'fullName': 'full_name',
                'book_title': 'bookTitle',
                'bookTitle': 'book_title',
                'author_name': 'authorName',
                'authorName': 'author_name',
                'review_notes': 'rejectionReason',
                'rejectionReason': 'review_notes'
            };
            
            // Check the known mappings
            if (knownMappings[key] && request[knownMappings[key]] !== undefined) {
                return request[knownMappings[key]];
            }
            
            // Default fallback
            return fallback;
        }

        /**
         * Shows a detailed confirmation popup with enhanced visibility
         * @param {Object} options - Options for the confirmation
         */
        function showDetailedConfirmation(options) {
            const confirmationEl = document.getElementById('detailedConfirmation');
            if (!confirmationEl) {
                console.error('[CRITICAL] detailedConfirmation element not found in DOM');
                alert(`${options.message}: ${options.details}`); // Fallback to alert
                return;
            }
            
            console.log('[DEBUG] Showing detailed confirmation popup');
            
            // Create content
            confirmationEl.innerHTML = `
                <div class="content-container" id="detailedConfirmationContent">
                    <button class="close-button" id="confirmationCloseBtn">&times;</button>
                    <div class="flex items-center mb-4">
                        <span class="header-icon mr-3">
                            ${getIconForType(options.type)}
                        </span>
                        <h3 class="message-title" id="confirmationTitle">${options.message}</h3>
                    </div>
                    <p class="message-details" id="confirmationDetails">${options.details}</p>
                    ${options.fileStatus ? createFileStatusBadge(options.fileStatus) : ''}
                    <div class="buttons-container">
                        <button class="ok-button" id="confirmationOkBtn">OK</button>
                    </div>
                </div>
            `;
            
            // Set type class
            confirmationEl.className = options.type || 'success';
            
            // Make sure it's in the document
            if (!document.body.contains(confirmationEl)) {
            document.body.appendChild(confirmationEl);
            }
            
            // Ensure visibility with stronger display settings
            confirmationEl.style.display = 'block';
            confirmationEl.style.opacity = '1';
            confirmationEl.style.visibility = 'visible';
            confirmationEl.style.zIndex = '3000';
            
            // Add event listeners
            const closeBtn = document.getElementById('confirmationCloseBtn');
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                confirmationEl.style.display = 'none';
            });
            }
            
            const okBtn = document.getElementById('confirmationOkBtn');
            if (okBtn) {
                okBtn.addEventListener('click', () => {
                confirmationEl.style.display = 'none';
            });
            }
            
            // Force visibility check and reapply if needed
            setTimeout(() => {
                console.log('[DEBUG] Confirmation popup display state:', 
                    window.getComputedStyle(confirmationEl).display);
                
                // Triple check visibility
                if (window.getComputedStyle(confirmationEl).display !== 'block') {
                    console.log('[DEBUG] Forcing visibility with !important style');
                    confirmationEl.setAttribute('style', 
                        'display: block !important; ' +
                        'z-index: 3000 !important; ' +
                        'opacity: 1 !important; ' +
                        'visibility: visible !important; ' +
                        'position: fixed !important; ' +
                        'top: 50% !important; ' +
                        'left: 50% !important; ' +
                        'transform: translate(-50%, -50%) !important;'
                    );
                }
            }, 50);
        }

        // Helper functions for the confirmation popup
        function getIconForType(type) {
            switch (type) {
                case 'success': return '<i class="fas fa-check-circle header-icon" style="color: var(--primary-green);"></i>';
                case 'warning': return '<i class="fas fa-exclamation-triangle header-icon" style="color: var(--gold-accent);"></i>';
                case 'error': return '<i class="fas fa-times-circle header-icon" style="color: var(--danger-red);"></i>';
                default: return '<i class="fas fa-info-circle header-icon" style="color: var(--primary-green);"></i>';
            }
        }

        function createFileStatusBadge(status) {
            let icon, label, color;
            
            switch (status) {
                case 'attached':
                    icon = 'fa-file-pdf';
                    label = 'Document Attached';
                    color = 'bg-emerald-100 text-emerald-800 border-emerald-200';
                    break;
                case 'missing':
                    icon = 'fa-file-excel';
                    label = 'Document Not Found';
                    color = 'bg-red-100 text-red-800 border-red-200';
                    break;
                case 'processing':
                    icon = 'fa-cog fa-spin';
                    label = 'Email Processing in Background';
                    color = 'bg-blue-100 text-blue-800 border-blue-200';
                    break;
                case 'uncertain':
                case 'pending':
                case 'failed':
                default:
                    icon = 'fa-file-search';
                    label = 'Document Status Uncertain';
                    color = 'bg-amber-100 text-amber-800 border-amber-200';
            }
            
            return `
            <div id="fileStatusBadge" class="file-status-badge ${color} my-3">
                <i class="fas ${icon} file-status-icon"></i>
                <span>${label}</span>
            </div>`;
        }

        /** Formats a file size in bytes to a human-readable format */
        function formatFileSize(bytes) {
            if (!bytes || isNaN(bytes) || bytes <= 0) return 'unknown size';
            const units = ['B', 'KB', 'MB', 'GB', 'TB'];
            let i = 0;
            let size = Number(bytes);
            while (size >= 1024 && i < units.length - 1) {
                size /= 1024;
                i++;
            }
            return `${size.toFixed(i === 0 ? 0 : 1)} ${units[i]}`;
        }

        /** Handles rejection of a request with a reason. */
        async function rejectRequest(requestId, reason) {
            try {
                // Get token using our helper function
                const token = getAuthToken();
                if (!token) {
                    throw new Error('No authentication token found. Please log in again.');
                }

                // Check if user is admin
                const userInfo = JSON.parse(sessionStorage.getItem('userInfo') || '{}');
                if (!userInfo.role || userInfo.role.toLowerCase() !== 'admin') {
                    throw new Error('You do not have permission to perform this action. Admin access required.');
                }

                // Process rejection through API
                const response = await fetch(`/api/document-requests/${requestId}/status`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        status: 'rejected',
                        reviewedBy: userInfo.id || 'admin',
                        reviewNotes: reason || 'Rejected by admin'
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Failed to reject request: ${response.status} ${errorText}`);
                }

                // Update local state
                const requestIndex = requests.findIndex(req => req.id === requestId);
                if (requestIndex !== -1) {
                    requests[requestIndex].status = 'rejected';
                    requests[requestIndex].rejectionReason = reason;
                    requests[requestIndex].processedAt = new Date().toISOString();
                }

                // Show confirmation
                showConfirmationMessage(`Request ${requestId} rejected successfully.`, 'success');
                closeRejectionModal();
                closeDetailsModal();
                applyFiltersAndSort();
            } catch (error) {
                console.error('Error rejecting request:', error);
                showConfirmationMessage('Failed to reject request. Please try again.', 'error');
                
                // If it's an authentication error, show login button
                if (error.message.includes('authentication') || error.message.includes('permission')) {
                    requestsContentContainer.innerHTML = `
                        <div class="text-center text-red-600 py-4">
                            <p>Error: ${error.message}</p>
                            <button onclick="window.location.href='/log-in.html'" class="mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
                                Log in again
                            </button>
                        </div>`;
                }
            }
        }

        /** Updates the document link to include authentication token */
        function updateDocumentLink(linkElement, documentUrl) {
            if (!linkElement) {
                console.error('[Document Link] Missing link element');
                return;
            }
            
            if (!documentUrl || documentUrl === '#' || documentUrl === '/#') {
                console.error('[Document Link] Invalid URL:', documentUrl);
                // For invalid URLs, make the link show an error on click
                linkElement.onclick = function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    alert('Document link is not available');
                    return false;
                };
                return;
            }
            
            try {
                console.log('[Document Link] Updating document link with auth token for URL:', documentUrl);
                
                // Store the original URL without modification to preserve it
                const originalUrl = documentUrl;
                
                // Fix document URL if it's a relative path
                if (!documentUrl.startsWith('http') && !documentUrl.startsWith('/')) {
                    // Convert relative paths to absolute paths
                    documentUrl = '/' + documentUrl;
                    console.log('[Document Link] Converting to absolute path:', documentUrl);
                }
                
                // Make sure javascript: links aren't processed
                if (documentUrl.startsWith('javascript:')) {
                    console.log('[Document Link] Skipping javascript: link');
                    return;
                }
                
                // Set a click handler that will refresh the auth at the time of click
                linkElement.onclick = function(e) {
                    // Prevent the default navigation
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Final check for valid URL
                    if (!originalUrl || originalUrl === '#' || originalUrl === '/#') {
                        console.error('[Document Link] Invalid URL detected at click time:', originalUrl);
                        alert('Document is not available');
                    return false;
                }
                    
                    // Fix document URL if it's a relative path
                    let urlToUse = originalUrl;
                    if (!urlToUse.startsWith('http') && !urlToUse.startsWith('/')) {
                        urlToUse = '/' + urlToUse;
                        console.log('[Document Link] Fixed relative URL at click time:', urlToUse);
                    }
                    
                    console.log('[Document Link] Navigating to document URL:', urlToUse);
                    
                    // Get the most up-to-date token at click time
                    const token = getAuthToken();
                    
                    // Prepare the final URL with auth parameter
                    let finalUrl;
                    const hasParams = urlToUse.includes('?');
                    const separator = hasParams ? '&' : '?';
                    
                    if (token) {
                        console.log('[Document Link] Using token authentication');
                        finalUrl = `${urlToUse}${separator}auth_token=${token}&ts=${Date.now()}`;
                    } else {
                        console.log('[Document Link] Using cookie authentication');
                        finalUrl = `${urlToUse}${separator}use_cookie_auth=true&ts=${Date.now()}`;
                    }
                    
                    // Force opening in a new tab for document viewing
                    console.log('[Document Link] Opening document in new tab:', finalUrl);
                    try {
                        window.open(finalUrl, '_blank');
                    } catch (err) {
                        console.error('[Document Link] Error opening window:', err);
                        // Fallback - try directly setting location
                        alert('Document viewer will open in a new tab');
                        setTimeout(() => {
                            window.open(finalUrl, '_blank');
                        }, 100);
                    }
                    
                    return false; // Prevent default and stop propagation
                };
                
                // Also update the href for non-JS users (though click handler will intercept with JS enabled)
                const token = getAuthToken();
                
                // Keep the original URL as a data attribute for reference
                linkElement.setAttribute('data-original-url', originalUrl);
                linkElement.setAttribute('data-needs-auth', 'true');
                
                // Set target to _blank to open in new tab
                linkElement.setAttribute('target', '_blank');
                
                // Update href with authentication for non-JS fallback
                let hrefWithAuth;
                const hasParams = documentUrl.includes('?');
                const separator = hasParams ? '&' : '?';
                
                if (token) {
                    hrefWithAuth = `${documentUrl}${separator}auth_token=${token}`;
                } else {
                    hrefWithAuth = `${documentUrl}${separator}use_cookie_auth=true`;
                }
                
                linkElement.href = hrefWithAuth;
                
            } catch (error) {
                console.error('[Document Link] Error updating document link with auth token:', error);
                
                // Fallback to basic href without authentication
                linkElement.href = documentUrl;
            }
        }

        /**
         * Helper function to get the authentication token from multiple sources
         * @returns {string|null} The authentication token or null if not found
         */
        function getAuthToken() {
            try {
                // Check session storage first (main source)
                const sessionData = sessionStorage.getItem('userInfo');
                if (sessionData) {
                    const userInfo = JSON.parse(sessionData);
                    if (userInfo && userInfo.token) {
                        return userInfo.token;
                    }
                }
                
                // Try localStorage as fallback
                const localData = localStorage.getItem('userInfo');
                if (localData) {
                    const userInfo = JSON.parse(localData);
                    if (userInfo && userInfo.token) {
                        return userInfo.token;
                    }
                }
                
                // Try other known storage locations
                const authToken = localStorage.getItem('authToken') || 
                                 sessionStorage.getItem('authToken') ||
                                 localStorage.getItem('token') ||
                                 sessionStorage.getItem('token');
                                 
                if (authToken) {
                    return authToken;
                }
                
                // If we reach here, no token was found
                return null;
            } catch (error) {
                console.error('[Auth] Error getting auth token:', error);
                return null;
            }
        }

        /**
         * Tries to fetch a fresh auth token from the server
         * @returns {Promise<string|null>} A promise that resolves to the token or null
         */
        async function refreshAuthToken() {
            try {
                console.log('[Auth] Attempting to refresh authentication token');
                
                // Try a different endpoint - users endpoint is more likely to exist than profile
                const response = await fetch('/api/auth/status', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include'
                });
                
                if (response.ok) {
                    const userData = await response.json();
                    if (userData && userData.token) {
                        // Save the token in both storages for redundancy
                        const userInfo = { token: userData.token, role: userData.role || 'user' };
                        sessionStorage.setItem('userInfo', JSON.stringify(userInfo));
                        localStorage.setItem('userInfo', JSON.stringify(userInfo));
                        
                        console.log('[Auth] Successfully refreshed auth token');
                        return userData.token;
                    }
                }
                
                // If the first endpoint fails, try a fallback endpoint
                console.log('[Auth] First refresh endpoint failed, trying fallback');
                const fallbackResponse = await fetch('/api/users/current', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include'
                });
                
                if (fallbackResponse.ok) {
                    const fallbackData = await fallbackResponse.json();
                    if (fallbackData && fallbackData.token) {
                        // Save the token
                        const userInfo = { token: fallbackData.token, role: fallbackData.role || 'user' };
                        sessionStorage.setItem('userInfo', JSON.stringify(userInfo));
                        localStorage.setItem('userInfo', JSON.stringify(userInfo));
                        
                        console.log('[Auth] Successfully refreshed auth token from fallback endpoint');
                        return fallbackData.token;
                    }
                }
                
                // If we get here, could not get a new token
                console.error('[Auth] Failed to refresh auth token from any endpoint');
                return null;
            } catch (error) {
                console.error('[Auth] Error refreshing auth token:', error);
                return null;
            }
        }
        
        // Function to initialize all document links with authentication tokens
        function initDocumentLinks() {
            console.log('[Document Links] Initializing document link authentication');
            
            // Process any existing links first
            updateAllDocumentLinks();
            
            // Set up a mutation observer to add auth tokens to document links added dynamically
            const observer = new MutationObserver((mutations) => {
                mutations.forEach(mutation => {
                    if (mutation.type === 'childList') {
                        mutation.addedNodes.forEach(node => {
                            if (node.nodeType === 1) { // Element node
                                // Check if the node itself is a link that needs auth
                                if ((node.classList && node.classList.contains('view-doc-button') || 
                                     node.hasAttribute('data-needs-auth')) && 
                                    !node.hasAttribute('data-auth-processed')) {
                                    updateDocumentLink(node, node.getAttribute('href'));
                                    node.setAttribute('data-auth-processed', 'true');
                                }
                                
                                // Check for links inside the added node
                                const links = node.querySelectorAll('a.view-doc-button, a[data-needs-auth="true"]');
                                links.forEach(link => {
                                    if (!link.hasAttribute('data-auth-processed')) {
                                        updateDocumentLink(link, link.getAttribute('href'));
                                        link.setAttribute('data-auth-processed', 'true');
                                    }
                                });
                            }
                        });
                    }
                });
            });
            
            // Start observing the document with the configured parameters
            observer.observe(document.body, { childList: true, subtree: true });
            console.log('[Document Links] Observer set up for document links');
            
            // Set a periodic check for links that need updating
            setInterval(updateAllDocumentLinks, 30000); // Check every 30 seconds
            
            // Try to refresh the token once at startup
            refreshAuthToken().then(newToken => {
                if (newToken) {
                    // If we got a new token, update all links
                    updateAllDocumentLinks();
                }
            });
        }
        
        // Helper function to update all document links
        function updateAllDocumentLinks() {
            console.log('[Document Links] Updating all document links');
            
            // Process all view-doc-button links and data-needs-auth links
            document.querySelectorAll('a.view-doc-button, a[data-needs-auth="true"]').forEach(link => {
                // Get the original URL, falling back to href if needed
                const originalUrl = link.getAttribute('data-original-url') || link.href;
                
                // Don't process empty links or javascript: links
                if (!originalUrl || originalUrl === '#' || originalUrl.startsWith('javascript:')) {
                    return;
                }
                
                // Remove protocols and domain from href when comparing to avoid false differences
                const cleanHref = link.href.replace(/^https?:\/\/[^\/]+/, '');
                const cleanOriginal = originalUrl.replace(/^https?:\/\/[^\/]+/, '');
                
                // Skip links that already have auth tokens
                if (cleanHref.includes('auth_token=') || cleanHref.includes('use_cookie_auth=')) {
                    if (cleanHref.includes(cleanOriginal)) {
                        console.log('[Document Links] Link already has auth, skipping:', cleanOriginal);
                        return;
                    }
                }
                
                console.log('[Document Links] Updating link:', originalUrl);
                updateDocumentLink(link, originalUrl);
                link.setAttribute('data-auth-processed', 'true');
            });
        }
      </script>
  

</body>
</html>
